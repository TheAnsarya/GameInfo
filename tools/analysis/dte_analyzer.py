#!/usr/bin/env python3
"""
DTE (Dual Tile Encoding) Analyzer - Analyze and optimize DTE compression

Analyzes text data to find optimal DTE pairs for compression.
Supports multiple encoding schemes and provides compression statistics.
"""

import argparse
import json
import re
import sys
from collections import Counter
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple


class DTEPair:
	"""Represents a DTE pair."""

	def __init__(
		self,
		byte_value: int,
		chars: str,
		count: int = 0,
		savings: int = 0,
	):
		self.byte_value = byte_value
		self.chars = chars
		self.count = count
		self.savings = savings

	def to_dict(self) -> Dict:
		return {
			"byte": f"${self.byte_value:02X}",
			"chars": self.chars,
			"count": self.count,
			"savings": self.savings,
		}


class DTEAnalyzer:
	"""Analyzes text for DTE compression opportunities."""

	def __init__(
		self,
		min_pair_length: int = 2,
		max_pair_length: int = 2,
		available_bytes: Optional[Set[int]] = None,
	):
		self.min_pair_length = min_pair_length
		self.max_pair_length = max_pair_length
		self.available_bytes = available_bytes or set(range(0x80, 0x100))
		self.pairs: Dict[str, DTEPair] = {}
		self.text_data: str = ""

	def analyze_text(self, text: str) -> List[DTEPair]:
		"""Analyze text and find optimal DTE pairs."""
		self.text_data = text

		# Count all substrings
		pair_counts: Counter = Counter()

		for length in range(self.min_pair_length, self.max_pair_length + 1):
			for i in range(len(text) - length + 1):
				substr = text[i:i + length]
				# Skip if contains control codes or special chars
				if "[" not in substr and "]" not in substr:
					pair_counts[substr] += 1

		# Filter to pairs that appear multiple times
		candidates = [(pair, count) for pair, count in pair_counts.items() if count >= 2]

		# Sort by savings (count * (length - 1))
		candidates.sort(key=lambda x: x[1] * (len(x[0]) - 1), reverse=True)

		# Assign available bytes to best pairs
		result = []
		available = sorted(self.available_bytes)
		byte_idx = 0

		for pair, count in candidates:
			if byte_idx >= len(available):
				break

			savings = count * (len(pair) - 1)
			dte_pair = DTEPair(
				byte_value=available[byte_idx],
				chars=pair,
				count=count,
				savings=savings,
			)
			result.append(dte_pair)
			byte_idx += 1

		return result

	def analyze_file(self, file_path: Path) -> List[DTEPair]:
		"""Analyze a text file."""
		text = file_path.read_text(encoding="utf-8", errors="replace")
		return self.analyze_text(text)

	def analyze_json_script(self, file_path: Path) -> List[DTEPair]:
		"""Analyze a JSON script file."""
		data = json.loads(file_path.read_text(encoding="utf-8"))

		# Combine all text entries
		combined = []
		for entry in data:
			text = entry.get("text", entry.get("original", ""))
			if text:
				combined.append(text)

		return self.analyze_text("\n".join(combined))

	def calculate_compression(self, pairs: List[DTEPair]) -> Dict:
		"""Calculate compression statistics."""
		original_size = len(self.text_data)
		compressed = self.text_data

		for pair in pairs:
			compressed = compressed.replace(pair.chars, chr(pair.byte_value))

		compressed_size = len(compressed)
		savings = original_size - compressed_size
		ratio = (compressed_size / original_size) * 100 if original_size > 0 else 100

		return {
			"original_size": original_size,
			"compressed_size": compressed_size,
			"savings": savings,
			"ratio": ratio,
			"pairs_used": len(pairs),
		}

	def generate_table(self, pairs: List[DTEPair]) -> str:
		"""Generate DTE table in .tbl format."""
		lines = [
			"; DTE (Dual Tile Encoding) Table",
			"; Generated by DTE Analyzer",
			";",
			"; Usage: High bytes expand to two characters",
			"",
		]

		for pair in sorted(pairs, key=lambda p: p.byte_value):
			# Escape special characters
			chars = pair.chars
			chars_display = chars.replace(" ", "<space>")

			line = f"{pair.byte_value:02X}={chars}"
			comment = f"; used {pair.count}x, saves {pair.savings} bytes"
			lines.append(f"{line}\t{comment}")

		return "\n".join(lines)

	def generate_asm_table(self, pairs: List[DTEPair]) -> str:
		"""Generate DTE table in assembly format."""
		lines = [
			"; DTE (Dual Tile Encoding) Expansion Table",
			"; Generated by DTE Analyzer",
			";",
			"; Format: Each entry is 2 bytes (the character pair)",
			"",
			"DTETable:",
		]

		# Sort by byte value
		sorted_pairs = sorted(pairs, key=lambda p: p.byte_value)

		# Fill gaps with placeholder
		byte_dict = {p.byte_value: p for p in sorted_pairs}

		if sorted_pairs:
			start = sorted_pairs[0].byte_value
			end = sorted_pairs[-1].byte_value

			for byte_val in range(start, end + 1):
				if byte_val in byte_dict:
					pair = byte_dict[byte_val]
					# Get byte values for each character (assuming ASCII-ish)
					char1 = ord(pair.chars[0]) if len(pair.chars) > 0 else 0
					char2 = ord(pair.chars[1]) if len(pair.chars) > 1 else 0
					lines.append(f"\t.byte ${char1:02X}, ${char2:02X}\t; ${byte_val:02X} = \"{pair.chars}\"")
				else:
					lines.append(f"\t.byte $00, $00\t; ${byte_val:02X} (unused)")

		return "\n".join(lines)


class MTE3Analyzer(DTEAnalyzer):
	"""MTE (Multiple Tile Encoding) with 3+ character sequences."""

	def __init__(
		self,
		min_length: int = 2,
		max_length: int = 8,
		available_bytes: Optional[Set[int]] = None,
	):
		super().__init__(min_length, max_length, available_bytes)

	def analyze_text(self, text: str) -> List[DTEPair]:
		"""Analyze for multi-character sequences."""
		self.text_data = text

		# Count all substrings
		pair_counts: Counter = Counter()

		for length in range(self.min_pair_length, self.max_pair_length + 1):
			for i in range(len(text) - length + 1):
				substr = text[i:i + length]
				# Skip if contains control codes
				if "[" not in substr and "]" not in substr:
					# Only count if it's worth compressing
					if len(substr) >= 2:
						pair_counts[substr] += 1

		# Filter and calculate real savings
		candidates = []
		for pair, count in pair_counts.items():
			if count >= 2:
				# Savings = occurrences * (length - 1)
				savings = count * (len(pair) - 1)
				candidates.append((pair, count, savings))

		# Sort by total savings
		candidates.sort(key=lambda x: x[2], reverse=True)

		# Greedy selection to avoid overlapping pairs
		selected_text = text
		result = []
		available = sorted(self.available_bytes)
		byte_idx = 0

		for pair, count, savings in candidates:
			if byte_idx >= len(available):
				break

			# Recount in current text (after previous replacements)
			actual_count = selected_text.count(pair)
			if actual_count < 2:
				continue

			actual_savings = actual_count * (len(pair) - 1)

			dte_pair = DTEPair(
				byte_value=available[byte_idx],
				chars=pair,
				count=actual_count,
				savings=actual_savings,
			)
			result.append(dte_pair)

			# Replace in working text to avoid double-counting
			selected_text = selected_text.replace(pair, chr(available[byte_idx]))
			byte_idx += 1

		return result


def find_optimal_dte(
	text: str,
	max_pairs: int = 128,
	min_length: int = 2,
	max_length: int = 2,
) -> List[DTEPair]:
	"""Find optimal DTE pairs for text."""
	available = set(range(0x80, 0x80 + max_pairs))
	analyzer = DTEAnalyzer(min_length, max_length, available)
	return analyzer.analyze_text(text)


def main():
	"""Main entry point."""
	parser = argparse.ArgumentParser(
		description="DTE Analyzer - Analyze and optimize DTE compression",
		formatter_class=argparse.RawDescriptionHelpFormatter,
		epilog="""
Examples:
	# Analyze text file
	python dte_analyzer.py analyze script.txt

	# Analyze with MTE (longer sequences)
	python dte_analyzer.py analyze script.txt --max-length 8

	# Generate DTE table
	python dte_analyzer.py table script.txt -o dte.tbl

	# Generate ASM table
	python dte_analyzer.py asm script.txt -o dte_table.asm

	# Show compression statistics
	python dte_analyzer.py stats script.txt --pairs 64

	# Analyze JSON script
	python dte_analyzer.py analyze script.json --json
		""",
	)

	subparsers = parser.add_subparsers(dest="command", help="Command")

	# Analyze command
	analyze_parser = subparsers.add_parser("analyze", help="Analyze text for DTE pairs")
	analyze_parser.add_argument("input", help="Input text or JSON file")
	analyze_parser.add_argument("--json", action="store_true", help="Input is JSON script")
	analyze_parser.add_argument("--max-length", type=int, default=2, help="Max sequence length")
	analyze_parser.add_argument("--max-pairs", type=int, default=128, help="Max DTE pairs")
	analyze_parser.add_argument("--top", type=int, default=20, help="Show top N pairs")

	# Table command
	table_parser = subparsers.add_parser("table", help="Generate DTE table")
	table_parser.add_argument("input", help="Input text or JSON file")
	table_parser.add_argument("-o", "--output", required=True, help="Output .tbl file")
	table_parser.add_argument("--json", action="store_true", help="Input is JSON script")
	table_parser.add_argument("--max-length", type=int, default=2, help="Max sequence length")
	table_parser.add_argument("--max-pairs", type=int, default=128, help="Max DTE pairs")

	# ASM command
	asm_parser = subparsers.add_parser("asm", help="Generate ASM expansion table")
	asm_parser.add_argument("input", help="Input text or JSON file")
	asm_parser.add_argument("-o", "--output", required=True, help="Output .asm file")
	asm_parser.add_argument("--json", action="store_true", help="Input is JSON script")
	asm_parser.add_argument("--max-length", type=int, default=2, help="Max sequence length")
	asm_parser.add_argument("--max-pairs", type=int, default=128, help="Max DTE pairs")

	# Stats command
	stats_parser = subparsers.add_parser("stats", help="Show compression statistics")
	stats_parser.add_argument("input", help="Input text or JSON file")
	stats_parser.add_argument("--json", action="store_true", help="Input is JSON script")
	stats_parser.add_argument("--pairs", type=int, default=128, help="Number of DTE pairs")
	stats_parser.add_argument("--max-length", type=int, default=2, help="Max sequence length")

	args = parser.parse_args()

	if not args.command:
		parser.print_help()
		return 1

	input_path = Path(args.input)
	if not input_path.exists():
		print(f"Error: File not found: {input_path}", file=sys.stderr)
		return 1

	try:
		# Set up analyzer
		max_pairs = getattr(args, "max_pairs", 128)
		max_length = getattr(args, "max_length", 2)
		available = set(range(0x80, 0x80 + max_pairs))

		if max_length > 2:
			analyzer = MTE3Analyzer(2, max_length, available)
		else:
			analyzer = DTEAnalyzer(2, max_length, available)

		# Load and analyze
		if getattr(args, "json", False):
			pairs = analyzer.analyze_json_script(input_path)
		else:
			pairs = analyzer.analyze_file(input_path)

		if args.command == "analyze":
			print(f"\nDTE Analysis for: {input_path.name}")
			print("=" * 60)

			stats = analyzer.calculate_compression(pairs)
			print(f"Original size: {stats['original_size']:,} bytes")
			print(f"Max sequence length: {max_length}")
			print(f"Pairs found: {len(pairs)}")
			print()

			print(f"Top {args.top} DTE pairs:")
			print("-" * 50)
			print(f"{'Byte':>6}  {'Chars':<12}  {'Count':>6}  {'Savings':>8}")
			print("-" * 50)

			for pair in pairs[:args.top]:
				chars_display = pair.chars.replace(" ", "·").replace("\n", "↵")
				if len(chars_display) > 10:
					chars_display = chars_display[:10] + "…"
				print(f"${pair.byte_value:02X}    \"{chars_display}\"{'':>{10-len(chars_display)}}  {pair.count:6d}  {pair.savings:8d}")

		elif args.command == "table":
			table_content = analyzer.generate_table(pairs)
			output_path = Path(args.output)
			output_path.write_text(table_content, encoding="utf-8")
			print(f"Generated DTE table with {len(pairs)} entries")
			print(f"Saved: {output_path}")

		elif args.command == "asm":
			asm_content = analyzer.generate_asm_table(pairs)
			output_path = Path(args.output)
			output_path.write_text(asm_content, encoding="utf-8")
			print(f"Generated ASM table with {len(pairs)} entries")
			print(f"Saved: {output_path}")

		elif args.command == "stats":
			stats = analyzer.calculate_compression(pairs)

			print(f"\nCompression Statistics for: {input_path.name}")
			print("=" * 50)
			print(f"Original size:   {stats['original_size']:>10,} bytes")
			print(f"Compressed size: {stats['compressed_size']:>10,} bytes")
			print(f"Savings:         {stats['savings']:>10,} bytes")
			print(f"Compression:     {100 - stats['ratio']:>10.1f}%")
			print(f"DTE pairs used:  {stats['pairs_used']:>10}")

			# Show breakdown by savings
			print("\nSavings breakdown:")
			print("-" * 40)

			ranges = [(100, float('inf')), (50, 100), (20, 50), (10, 20), (1, 10)]
			for low, high in ranges:
				count = sum(1 for p in pairs if low <= p.savings < high)
				total_savings = sum(p.savings for p in pairs if low <= p.savings < high)
				if count > 0:
					if high == float('inf'):
						print(f"  ≥{low} bytes: {count} pairs, {total_savings} bytes saved")
					else:
						print(f"  {low}-{high} bytes: {count} pairs, {total_savings} bytes saved")

	except Exception as e:
		print(f"Error: {e}", file=sys.stderr)
		return 1

	return 0


if __name__ == "__main__":
	sys.exit(main())
