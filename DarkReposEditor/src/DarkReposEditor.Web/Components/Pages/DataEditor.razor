@page "/data-editor"
@page "/data-editor/{RomId:guid}"
@using DarkReposEditor.Core.Interfaces
@using DarkReposEditor.Core.Services
@using DataTable = DarkReposEditor.Core.Interfaces.DataTable
@inject IDataEditorService DataEditorService
@inject IRomService RomService
@inject IJSRuntime JSRuntime

<PageTitle>Data Editor - DarkReposEditor</PageTitle>

<div class="data-editor">
	<div class="toolbar">
		<div class="toolbar-group">
			<label>Structure:</label>
			<select @bind="SelectedTemplate" class="template-select">
				<option value="">-- Custom --</option>
				@foreach (var template in _templates)
				{
					<option value="@template.Name">@template.Name - @template.Category</option>
				}
			</select>
			<button class="btn btn-primary" @onclick="LoadStructureDefinitionAsync" title="Load custom JSON schema">
				<span class="icon">üìÑ</span> Load Schema
			</button>
		</div>

		<div class="toolbar-group">
			<label>Offset:</label>
			<input type="text" @bind="OffsetHex" placeholder="0x0000" class="offset-input" />
			<label>Count:</label>
			<input type="number" @bind="RecordCount" min="1" max="9999" class="count-input" />
			<button class="btn btn-success" @onclick="LoadDataTableAsync" disabled="@(!CanLoadTable)" title="Load data from ROM">
				<span class="icon">üì•</span> Load
			</button>
		</div>

		<div class="toolbar-group">
			<button class="btn btn-secondary" @onclick="ExportToJsonAsync" disabled="@(!HasData)" title="Export to JSON">
				<span class="icon">üìã</span> JSON
			</button>
			<button class="btn btn-secondary" @onclick="ExportToCsvAsync" disabled="@(!HasData)" title="Export to CSV">
				<span class="icon">üìä</span> CSV
			</button>
			<button class="btn btn-secondary" @onclick="ImportFromJsonAsync" disabled="@(_currentStructure == null)" title="Import from JSON">
				<span class="icon">üì§</span> Import JSON
			</button>
			<button class="btn btn-secondary" @onclick="ImportFromCsvAsync" disabled="@(_currentStructure == null)" title="Import from CSV">
				<span class="icon">üìà</span> Import CSV
			</button>
		</div>

		<div class="toolbar-group">
			<button class="btn btn-warning" @onclick="ValidateTableAsync" disabled="@(!HasData)" title="Validate data">
				<span class="icon">‚úì</span> Validate
			</button>
			<button class="btn btn-info" @onclick="DetectTablesAsync" title="Auto-detect tables in ROM">
				<span class="icon">üîç</span> Detect
			</button>
			<button class="btn btn-danger" @onclick="SaveChangesAsync" disabled="@(!HasModifications)" title="Save to ROM">
				<span class="icon">üíæ</span> Save
			</button>
		</div>
	</div>

	<div class="main-content">
		<div class="structure-panel">
			<div class="panel-header">
				<h3>Structure Definition</h3>
				<button class="btn btn-sm btn-secondary" @onclick="ToggleStructureEdit" title="Edit structure">
					<span class="icon">‚úèÔ∏è</span>
				</button>
			</div>

			@if (_isEditingStructure)
			{
				<div class="structure-editor">
					<textarea @bind="_structureJson" rows="20" class="schema-textarea" placeholder="Enter JSON schema..."></textarea>
					<div class="editor-actions">
						<button class="btn btn-sm btn-success" @onclick="ApplyStructureAsync">Apply</button>
						<button class="btn btn-sm btn-secondary" @onclick="CancelStructureEdit">Cancel</button>
					</div>
				</div>
			}
			else if (_currentStructure != null)
			{
				<div class="structure-info">
					<div class="info-row">
						<span class="label">Name:</span>
						<span class="value">@_currentStructure.Name</span>
					</div>
					<div class="info-row">
						<span class="label">Record Size:</span>
						<span class="value">@_currentStructure.RecordSize bytes</span>
					</div>
					<div class="info-row">
						<span class="label">Endianness:</span>
						<span class="value">@_currentStructure.Endianness</span>
					</div>
					<div class="fields-list">
						<h4>Fields (@_currentStructure.Fields.Count)</h4>
						@foreach (var field in _currentStructure.Fields)
						{
							<div class="field-item">
								<span class="field-name">@field.Name</span>
								<span class="field-type">@field.Type</span>
								<span class="field-size">@field.GetByteSize()B</span>
							</div>
						}
					</div>
				</div>
			}
			else
			{
				<div class="empty-state">
					<p>Select a template or load a schema to begin.</p>
				</div>
			}
		</div>

		<div class="data-panel">
			<div class="panel-header">
				<h3>Data Table</h3>
				@if (_currentTable != null)
				{
					<span class="record-count">@_currentTable.Records.Count records</span>
				}
			</div>

			@if (_currentTable != null && _currentStructure != null)
			{
				<div class="data-table-container">
					<table class="data-table">
						<thead>
							<tr>
								<th class="row-num">#</th>
								<th class="offset">Offset</th>
								@foreach (var field in _currentStructure.Fields)
								{
									<th class="field-header" title="@field.Description">
										@(string.IsNullOrEmpty(field.Label) ? field.Name : field.Label)
									</th>
								}
							</tr>
						</thead>
						<tbody>
							@for (int i = 0; i < _currentTable.Records.Count; i++)
							{
								var record = _currentTable.Records[i];
								var rowIndex = i;
								<tr class="@(record.IsModified ? "modified" : "") @(rowIndex == _selectedRow ? "selected" : "")"
									@onclick="() => SelectRow(rowIndex)">
									<td class="row-num">@i</td>
									<td class="offset">@@$"{record.Offset:x6}"</td>
									@foreach (var field in _currentStructure.Fields)
									{
										<td class="field-value @(HasValidationError(rowIndex, field.Name) ? "has-error" : "")">
											@RenderFieldInput(record, field, rowIndex)
										</td>
									}
								</tr>
							}
						</tbody>
					</table>
				</div>
			}
			else
			{
				<div class="empty-state">
					<p>Load a data table to view and edit records.</p>
				</div>
			}
		</div>

		<div class="details-panel">
			<div class="panel-header">
				<h3>Details</h3>
			</div>

			@if (_selectedRow >= 0 && _currentTable != null)
			{
				var record = _currentTable.Records[_selectedRow];
				<div class="record-details">
					<div class="detail-section">
						<h4>Record @_selectedRow</h4>
						<div class="info-row">
							<span class="label">Offset:</span>
							<span class="value">@@$"0x{record.Offset:x6}"</span>
						</div>
						@if (!string.IsNullOrEmpty(record.Label))
						{
							<div class="info-row">
								<span class="label">Label:</span>
								<span class="value">@record.Label</span>
							</div>
						}
						<div class="info-row">
							<span class="label">Modified:</span>
							<span class="value @(record.IsModified ? "modified-flag" : "")">@(record.IsModified ? "Yes" : "No")</span>
						</div>
					</div>

					<div class="detail-section">
						<h4>Raw Bytes</h4>
						<div class="hex-display">
							@for (int i = 0; i < record.RawBytes.Length; i++)
							{
								<span class="hex-byte">@record.RawBytes[i].ToString("x2")</span>
							}
						</div>
					</div>

					@if (_currentStructure != null)
					{
						<div class="detail-section">
							<h4>Field Values</h4>
							@foreach (var field in _currentStructure.Fields)
							{
								<div class="field-detail">
									<span class="field-name">@(string.IsNullOrEmpty(field.Label) ? field.Name : field.Label):</span>
									<span class="field-value">@FormatFieldValue(record, field)</span>
									@if (field.EnumValues != null && record.Values.TryGetValue(field.Name, out var enumVal))
									{
										var intVal = Convert.ToInt32(enumVal);
										if (field.EnumValues.TryGetValue(intVal, out var enumName))
										{
											<span class="enum-name">(@enumName)</span>
										}
									}
								</div>
							}
						</div>
					}
				</div>
			}
			else
			{
				<div class="empty-state">
					<p>Select a record to view details.</p>
				</div>
			}

			@if (_validationResult != null && !_validationResult.IsValid)
			{
				<div class="validation-errors">
					<h4>Validation Errors</h4>
					@foreach (var error in _validationResult.Errors)
					{
						<div class="error-item @(error.Severity == ValidationSeverity.Warning ? "warning" : "error")">
							<span class="error-location">
								@(error.RecordIndex.HasValue ? $"[{error.RecordIndex}]" : "") @error.FieldName
							</span>
							<span class="error-message">@error.Message</span>
						</div>
					}
				</div>
			}

			@if (_detectedTables != null && _detectedTables.Count > 0)
			{
				<div class="detected-tables">
					<h4>Detected Tables</h4>
					@foreach (var table in _detectedTables.Take(10))
					{
						<div class="detected-item" @onclick="() => SelectDetectedTable(table)">
							<span class="offset">@@$"0x{table.Offset:x6}"</span>
							<span class="info">~@table.EstimatedRows rows √ó @table.EstimatedRowSize bytes</span>
							<span class="confidence">@table.Confidence%</span>
						</div>
					}
				</div>
			}
		</div>
	</div>

	<div class="status-bar">
		<span class="status-item">
			@if (_currentTable != null)
			{
				<span>Table: @_currentTable.Name</span>
				<span class="separator">|</span>
				<span>Records: @_currentTable.Records.Count</span>
				<span class="separator">|</span>
				<span>Size: @_currentTable.TotalSize bytes</span>
			}
			else
			{
				<span>No data loaded</span>
			}
		</span>
		<span class="status-message">@_statusMessage</span>
	</div>
</div>

@code {
	private IReadOnlyList<StructureTemplate> _templates = [];
	private string _selectedTemplate = "";
	private string _structureJson = "";
	private bool _isEditingStructure = false;

	private DataStructure? _currentStructure;
	private DataTable? _currentTable;
	private DataValidationResult? _validationResult;
	private IReadOnlyList<DetectedTable>? _detectedTables;

	private string _offsetHex = "0x0000";
	private int _recordCount = 10;
	private int _selectedRow = -1;
	private string _statusMessage = "Ready";
	private byte[]? _romData;
	private Guid? _romId;

	[Parameter]
	public Guid? RomId { get; set; }

	public string SelectedTemplate
	{
		get => _selectedTemplate;
		set
		{
			if (_selectedTemplate != value)
			{
				_selectedTemplate = value;
				OnTemplateChanged();
			}
		}
	}

	public string OffsetHex
	{
		get => _offsetHex;
		set => _offsetHex = value;
	}

	public int RecordCount
	{
		get => _recordCount;
		set => _recordCount = Math.Max(1, Math.Min(9999, value));
	}

	private bool CanLoadTable => _currentStructure != null && _romData != null;
	private bool HasData => _currentTable != null && _currentTable.Records.Count > 0;
	private bool HasRomData => _romData != null && _romData.Length > 0;
	private bool HasModifications => _currentTable?.Records.Any(r => r.IsModified) == true;

	protected override async Task OnInitializedAsync()
	{
		_templates = DataEditorService.GetTemplates();

		// Load ROM data if RomId parameter is provided
		if (RomId.HasValue)
		{
			_romId = RomId.Value;
			var rom = await RomService.GetByIdAsync(RomId.Value);
			if (rom?.Data != null)
			{
				_romData = rom.Data;
				_statusMessage = $"ROM loaded: {rom.FileName} ({rom.Data.Length:N0} bytes)";
			}
			else
			{
				_statusMessage = "Error: ROM not found";
			}
		}
	}

	private void OnTemplateChanged()
	{
		if (string.IsNullOrEmpty(_selectedTemplate))
		{
			_currentStructure = null;
			_structureJson = "";
		}
		else
		{
			var template = _templates.FirstOrDefault(t => t.Name == _selectedTemplate);
			if (template != null)
			{
				_currentStructure = template.Structure;
				_statusMessage = $"Template '{template.Name}' loaded";
			}
		}
		StateHasChanged();
	}

	private async Task LoadStructureDefinitionAsync()
	{
		// In a real app, this would open a file dialog
		// For now, enable the structure editor
		_isEditingStructure = true;
		await Task.CompletedTask;
	}

	private void ToggleStructureEdit()
	{
		_isEditingStructure = !_isEditingStructure;
		if (_isEditingStructure && _currentStructure != null)
		{
			// Serialize current structure to JSON for editing
			_structureJson = System.Text.Json.JsonSerializer.Serialize(_currentStructure, new System.Text.Json.JsonSerializerOptions
			{
				WriteIndented = true,
				PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase
			});
		}
	}

	private async Task ApplyStructureAsync()
	{
		try
		{
			_currentStructure = DataEditorService.LoadStructureDefinition(_structureJson);
			_isEditingStructure = false;
			_selectedTemplate = "";
			_statusMessage = $"Custom structure '{_currentStructure.Name}' applied";
		}
		catch (Exception ex)
		{
			_statusMessage = $"Error: {ex.Message}";
		}
		await Task.CompletedTask;
	}

	private void CancelStructureEdit()
	{
		_isEditingStructure = false;
	}

	private async Task LoadDataTableAsync()
	{
		if (_currentStructure == null || _romData == null)
			return;

		try
		{
			var offset = ParseHexOffset(_offsetHex);
			_currentTable = DataEditorService.LoadDataTable(_romData, offset, _currentStructure, _recordCount);
			_selectedRow = _currentTable.Records.Count > 0 ? 0 : -1;
			_validationResult = null;
			_statusMessage = $"Loaded {_currentTable.Records.Count} records from offset 0x{offset:x6}";
		}
		catch (Exception ex)
		{
			_statusMessage = $"Error loading data: {ex.Message}";
		}
		await Task.CompletedTask;
	}

	private int ParseHexOffset(string hex)
	{
		hex = hex.Trim();
		if (hex.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
			hex = hex[2..];
		if (hex.StartsWith("$"))
			hex = hex[1..];
		return int.Parse(hex, System.Globalization.NumberStyles.HexNumber);
	}

	private async Task ExportToJsonAsync()
	{
		if (_currentTable == null) return;

		try
		{
			var json = DataEditorService.ExportToJson(_currentTable);
			await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", json);
			_statusMessage = "JSON copied to clipboard";
		}
		catch (Exception ex)
		{
			_statusMessage = $"Export error: {ex.Message}";
		}
	}

	private async Task ExportToCsvAsync()
	{
		if (_currentTable == null) return;

		try
		{
			var csv = DataEditorService.ExportToCsv(_currentTable);
			await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", csv);
			_statusMessage = "CSV copied to clipboard";
		}
		catch (Exception ex)
		{
			_statusMessage = $"Export error: {ex.Message}";
		}
	}

	private async Task ImportFromJsonAsync()
	{
		if (_currentStructure == null) return;

		try
		{
			var json = await JSRuntime.InvokeAsync<string>("navigator.clipboard.readText");
			if (!string.IsNullOrEmpty(json))
			{
				_currentTable = DataEditorService.ImportFromJson(json, _currentStructure);
				_selectedRow = _currentTable.Records.Count > 0 ? 0 : -1;
				_statusMessage = $"Imported {_currentTable.Records.Count} records from JSON";
			}
		}
		catch (Exception ex)
		{
			_statusMessage = $"Import error: {ex.Message}";
		}
	}

	private async Task ImportFromCsvAsync()
	{
		if (_currentStructure == null) return;

		try
		{
			var csv = await JSRuntime.InvokeAsync<string>("navigator.clipboard.readText");
			if (!string.IsNullOrEmpty(csv))
			{
				_currentTable = DataEditorService.ImportFromCsv(csv, _currentStructure);
				_selectedRow = _currentTable.Records.Count > 0 ? 0 : -1;
				_statusMessage = $"Imported {_currentTable.Records.Count} records from CSV";
			}
		}
		catch (Exception ex)
		{
			_statusMessage = $"Import error: {ex.Message}";
		}
	}

	private async Task ValidateTableAsync()
	{
		if (_currentTable == null) return;

		_validationResult = DataEditorService.ValidateTable(_currentTable);
		_statusMessage = _validationResult.IsValid
			? "Validation passed"
			: $"Validation found {_validationResult.Errors.Count} errors";
		await Task.CompletedTask;
	}

	private async Task DetectTablesAsync()
	{
		if (_romData == null)
		{
			_statusMessage = "No ROM loaded";
			return;
		}

		try
		{
			var options = new DataTableDetectionOptions
			{
				MinRowSize = 4,
				MaxRowSize = 64,
				MinRows = 8,
				MinConfidence = 50,
				RomSize = _romData.Length
			};
			_detectedTables = DataEditorService.DetectTables(_romData, options);
			_statusMessage = $"Detected {_detectedTables.Count} potential tables";
		}
		catch (Exception ex)
		{
			_statusMessage = $"Detection error: {ex.Message}";
		}
		await Task.CompletedTask;
	}

	private void SelectDetectedTable(DetectedTable table)
	{
		_offsetHex = $"0x{table.Offset:x6}";
		_recordCount = table.EstimatedRows;
		_statusMessage = $"Selected table at 0x{table.Offset:x6}";
	}

	private async Task SaveChangesAsync()
	{
		if (_currentTable == null || _romData == null) return;

		try
		{
			var data = DataEditorService.ExportTable(_currentTable);
			Array.Copy(data, 0, _romData, _currentTable.Offset, data.Length);

			// Mark records as saved
			foreach (var record in _currentTable.Records)
			{
				record.IsModified = false;
			}

			// TODO: Save to ROM service if needed
			_statusMessage = $"Saved {data.Length} bytes to ROM at 0x{_currentTable.Offset:x6}";
		}
		catch (Exception ex)
		{
			_statusMessage = $"Save error: {ex.Message}";
		}
		await Task.CompletedTask;
	}

	private void SelectRow(int index)
	{
		_selectedRow = index;
	}

	private bool HasValidationError(int recordIndex, string fieldName)
	{
		return _validationResult?.Errors.Any(e => e.RecordIndex == recordIndex && e.FieldName == fieldName) == true;
	}

	private RenderFragment RenderFieldInput(DataRecord record, DataField field, int rowIndex) => builder =>
	{
		var value = record.Values.TryGetValue(field.Name, out var v) ? v : GetDefaultValue(field);

		if (field.ReadOnly)
		{
			builder.OpenElement(0, "span");
			builder.AddAttribute(1, "class", "readonly-value");
			builder.AddContent(2, FormatFieldValue(record, field));
			builder.CloseElement();
		}
		else if (field.Type == DataFieldType.Bool)
		{
			builder.OpenElement(0, "input");
			builder.AddAttribute(1, "type", "checkbox");
			builder.AddAttribute(2, "checked", Convert.ToBoolean(value));
			builder.AddAttribute(3, "onchange", EventCallback.Factory.Create<ChangeEventArgs>(this, e =>
				OnFieldValueChanged(record, field, e.Value)));
			builder.CloseElement();
		}
		else if (field.Type == DataFieldType.Enum && field.EnumValues != null)
		{
			builder.OpenElement(0, "select");
			builder.AddAttribute(1, "class", "field-select");
			builder.AddAttribute(2, "value", Convert.ToInt32(value));
			builder.AddAttribute(3, "onchange", EventCallback.Factory.Create<ChangeEventArgs>(this, e =>
				OnFieldValueChanged(record, field, e.Value)));

			foreach (var kvp in field.EnumValues)
			{
				builder.OpenElement(4, "option");
				builder.AddAttribute(5, "value", kvp.Key);
				builder.AddContent(6, kvp.Value);
				builder.CloseElement();
			}
			builder.CloseElement();
		}
		else if (field.Type == DataFieldType.Flags && field.EnumValues != null)
		{
			var flagValue = Convert.ToInt32(value);
			builder.OpenElement(0, "span");
			builder.AddAttribute(1, "class", "flags-display");
			builder.AddContent(2, FormatFlags(flagValue, field.EnumValues));
			builder.CloseElement();
		}
		else
		{
			builder.OpenElement(0, "input");
			builder.AddAttribute(1, "type", "text");
			builder.AddAttribute(2, "class", "field-input");
			builder.AddAttribute(3, "value", FormatFieldValue(record, field));
			builder.AddAttribute(4, "onchange", EventCallback.Factory.Create<ChangeEventArgs>(this, e =>
				OnFieldValueChanged(record, field, e.Value)));
			builder.CloseElement();
		}
	};

	private void OnFieldValueChanged(DataRecord record, DataField field, object? newValue)
	{
		if (newValue == null) return;

		try
		{
			var parsedValue = ParseFieldValue(newValue.ToString() ?? "", field);
			DataEditorService.SetFieldValue(record, field.Name, parsedValue);
			StateHasChanged();
		}
		catch (Exception ex)
		{
			_statusMessage = $"Error setting value: {ex.Message}";
		}
	}

	private object ParseFieldValue(string text, DataField field)
	{
		// Handle hex values
		if (text.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ||
			text.StartsWith("$") ||
			text.StartsWith("0X"))
		{
			var hex = text;
			if (hex.StartsWith("$")) hex = hex[1..];
			if (hex.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) hex = hex[2..];
			return field.Type switch
			{
				DataFieldType.Byte => byte.Parse(hex, System.Globalization.NumberStyles.HexNumber),
				DataFieldType.SByte => (sbyte)byte.Parse(hex, System.Globalization.NumberStyles.HexNumber),
				DataFieldType.Word => ushort.Parse(hex, System.Globalization.NumberStyles.HexNumber),
				DataFieldType.SWord => (short)ushort.Parse(hex, System.Globalization.NumberStyles.HexNumber),
				DataFieldType.DWord => uint.Parse(hex, System.Globalization.NumberStyles.HexNumber),
				DataFieldType.SDWord => (int)uint.Parse(hex, System.Globalization.NumberStyles.HexNumber),
				_ => int.Parse(hex, System.Globalization.NumberStyles.HexNumber)
			};
		}

		return field.Type switch
		{
			DataFieldType.Byte => byte.Parse(text),
			DataFieldType.SByte => sbyte.Parse(text),
			DataFieldType.Word => ushort.Parse(text),
			DataFieldType.SWord => short.Parse(text),
			DataFieldType.DWord => uint.Parse(text),
			DataFieldType.SDWord => int.Parse(text),
			DataFieldType.QWord => ulong.Parse(text),
			DataFieldType.SQWord => long.Parse(text),
			DataFieldType.Bool => bool.Parse(text),
			DataFieldType.FixedString => text,
			_ => int.Parse(text)
		};
	}

	private object GetDefaultValue(DataField field)
	{
		return field.Type switch
		{
			DataFieldType.Byte => (byte)0,
			DataFieldType.SByte => (sbyte)0,
			DataFieldType.Word => (ushort)0,
			DataFieldType.SWord => (short)0,
			DataFieldType.DWord => 0u,
			DataFieldType.SDWord => 0,
			DataFieldType.QWord => 0ul,
			DataFieldType.SQWord => 0L,
			DataFieldType.Bool => false,
			DataFieldType.FixedString => "",
			_ => 0
		};
	}

	private string FormatFieldValue(DataRecord record, DataField field)
	{
		if (!record.Values.TryGetValue(field.Name, out var value))
			return "-";

		var format = field.DisplayFormat ?? "";

		return field.Type switch
		{
			DataFieldType.Byte => format.StartsWith("X") ? $"${((byte)value):x2}" : value.ToString() ?? "",
			DataFieldType.SByte => value.ToString() ?? "",
			DataFieldType.Word => format.StartsWith("X") ? $"${((ushort)value):x4}" : value.ToString() ?? "",
			DataFieldType.SWord => value.ToString() ?? "",
			DataFieldType.DWord => format.StartsWith("X") ? $"${((uint)value):x8}" : value.ToString() ?? "",
			DataFieldType.SDWord => value.ToString() ?? "",
			DataFieldType.Pointer => $"${Convert.ToUInt32(value):x4}",
			DataFieldType.Bool => (bool)value ? "Yes" : "No",
			DataFieldType.Enum => FormatEnum(Convert.ToInt32(value), field.EnumValues),
			DataFieldType.Flags => FormatFlags(Convert.ToInt32(value), field.EnumValues),
			DataFieldType.FixedString => value.ToString() ?? "",
			_ => value.ToString() ?? ""
		};
	}

	private string FormatEnum(int value, Dictionary<int, string>? enumValues)
	{
		if (enumValues?.TryGetValue(value, out var name) == true)
			return name;
		return value.ToString();
	}

	private string FormatFlags(int value, Dictionary<int, string>? enumValues)
	{
		if (enumValues == null || value == 0)
			return value == 0 ? "None" : $"0x{value:x2}";

		var flags = enumValues
			.Where(kvp => (value & kvp.Key) != 0)
			.Select(kvp => kvp.Value);

		return string.Join(" | ", flags);
	}
}
