using System.Text;
using System.Text.Json;
using DarkRepos.Editor.Core.Interfaces;

namespace DarkRepos.Editor.Core.Services;

/// <summary>
/// Service for game text editing operations.
/// </summary>
public class TextEditorService : ITextEditorService
{
	public TableFile LoadTableFile(string tableContent)
	{
		var table = new TableFile();
		// Don't use TrimEntries - we need to preserve trailing space for space character mappings
		var lines = tableContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);

		foreach (var line in lines)
		{
			// Remove carriage return if present (Windows line endings)
			var cleanLine = line.TrimEnd('\r');

			// Skip empty lines and comments
			if (string.IsNullOrWhiteSpace(cleanLine) || cleanLine.StartsWith("//") || cleanLine.StartsWith("#"))
				continue;

			// Parse line format: XX=C or XXXX=CC or XX=<control>
			var eqIndex = cleanLine.IndexOf('=');
			if (eqIndex <= 0)
				continue;

			var hexPart = cleanLine[..eqIndex].Trim();
			var charPart = cleanLine[(eqIndex + 1)..];

			// For control codes (like <wait>), trim whitespace
			// For regular mappings, preserve space if that's the only character
			if (charPart.StartsWith("<") && charPart.EndsWith(">"))
			{
				// Control codes don't need trimming
			}
			else if (charPart != " ")
			{
				charPart = charPart.Trim();
			}

			// Parse hex value(s)
			var bytes = ParseHexString(hexPart);
			if (bytes.Length == 0)
				continue;

			// Check for special markers
			if (charPart == "<end>" || charPart == "[END]" || charPart == "/")
			{
				table.EndOfStringMarker = bytes;
				continue;
			}

			if (charPart == "<line>" || charPart == "[LINE]" || charPart == "\\n")
			{
				table.EndOfLineMarker = bytes;
				table.SingleByteMappings[bytes[0]] = "\n";
				continue;
			}

			// Check for control codes
			if (charPart.StartsWith('<') && charPart.EndsWith('>'))
			{
				table.ControlCodes[bytes] = charPart;
				continue;
			}

			// Regular character mapping
			if (bytes.Length == 1)
			{
				table.SingleByteMappings[bytes[0]] = charPart;
			}
			else
			{
				table.MultiByteMappings[bytes] = charPart;
				table.MaxSequenceLength = Math.Max(table.MaxSequenceLength, bytes.Length);
			}
		}

		table.BuildReverseMappings();
		return table;
	}

	public string GenerateTableFile(TableFile tableFile)
	{
		var sb = new StringBuilder();

		sb.AppendLine("// Table file generated by DarkReposEditor");
		sb.AppendLine($"// Name: {tableFile.Name}");
		sb.AppendLine();

		// End markers
		if (tableFile.EndOfStringMarker.Length > 0)
		{
			sb.AppendLine($"{FormatHexBytes(tableFile.EndOfStringMarker)}=<end>");
		}

		if (tableFile.EndOfLineMarker.Length > 0)
		{
			sb.AppendLine($"{FormatHexBytes(tableFile.EndOfLineMarker)}=<line>");
		}

		sb.AppendLine();

		// Control codes
		if (tableFile.ControlCodes.Count > 0)
		{
			sb.AppendLine("// Control codes");
			foreach (var kvp in tableFile.ControlCodes.OrderBy(k => k.Key[0]))
			{
				sb.AppendLine($"{FormatHexBytes(kvp.Key)}={kvp.Value}");
			}
			sb.AppendLine();
		}

		// Single byte mappings
		sb.AppendLine("// Character mappings");
		foreach (var kvp in tableFile.SingleByteMappings.OrderBy(k => k.Key))
		{
			var displayChar = kvp.Value == "\n" ? "\\n" : kvp.Value;
			sb.AppendLine($"{kvp.Key:x2}={displayChar}");
		}

		// Multi-byte mappings
		if (tableFile.MultiByteMappings.Count > 0)
		{
			sb.AppendLine();
			sb.AppendLine("// Multi-byte mappings");
			foreach (var kvp in tableFile.MultiByteMappings)
			{
				sb.AppendLine($"{FormatHexBytes(kvp.Key)}={kvp.Value}");
			}
		}

		// DTE mappings
		if (tableFile.DteMappings.Count > 0)
		{
			sb.AppendLine();
			sb.AppendLine("// DTE (Dual Tile Encoding)");
			foreach (var kvp in tableFile.DteMappings.OrderBy(k => k.Key))
			{
				sb.AppendLine($"{kvp.Key:x2}={kvp.Value}");
			}
		}

		return sb.ToString();
	}

	public string DecodeText(byte[] data, int offset, int length, TableFile table)
	{
		var result = new StringBuilder();
		var end = Math.Min(offset + length, data.Length);
		var pos = offset;

		while (pos < end)
		{
			// Check for end-of-string marker
			if (MatchesSequence(data, pos, table.EndOfStringMarker))
			{
				break;
			}

			// Try multi-byte sequences first (longest match)
			var matched = false;
			for (int seqLen = Math.Min(table.MaxSequenceLength, end - pos); seqLen > 1; seqLen--)
			{
				var sequence = new byte[seqLen];
				Array.Copy(data, pos, sequence, 0, seqLen);

				// Check control codes
				if (table.ControlCodes.TryGetValue(sequence, out var control))
				{
					result.Append(control);
					pos += seqLen;
					matched = true;
					break;
				}

				// Check multi-byte mappings
				if (table.MultiByteMappings.TryGetValue(sequence, out var multiChar))
				{
					result.Append(multiChar);
					pos += seqLen;
					matched = true;
					break;
				}
			}

			if (matched)
				continue;

			// Single byte lookup
			var b = data[pos];
			var singleByteSeq = new byte[] { b };

			// Check single-byte control codes first
			if (table.ControlCodes.TryGetValue(singleByteSeq, out var singleControl))
			{
				result.Append(singleControl);
			}
			// Check DTE
			else if (table.DteMappings.TryGetValue(b, out var dte))
			{
				result.Append(dte);
			}
			// Check MTE
			else if (table.MteMappings.TryGetValue(b, out var mte))
			{
				result.Append(mte);
			}
			// Check single byte
			else if (table.SingleByteMappings.TryGetValue(b, out var ch))
			{
				result.Append(ch);
			}
			else
			{
				// Unknown byte - show as hex
				result.Append($"[${b:x2}]");
			}

			pos++;
		}

		return result.ToString();
	}

	public byte[] EncodeText(string text, TableFile table)
	{
		var result = new List<byte>();
		var pos = 0;

		while (pos < text.Length)
		{
			var matched = false;

			// Try longest matches first
			for (int len = Math.Min(16, text.Length - pos); len > 0; len--)
			{
				var substr = text.Substring(pos, len);

				// Check for hex escapes like [$xx]
				if (substr.StartsWith("[$") && len >= 5 && substr.EndsWith("]"))
				{
					var hexPart = substr[2..^1];
					var bytes = ParseHexString(hexPart);
					if (bytes.Length > 0)
					{
						result.AddRange(bytes);
						pos += len;
						matched = true;
						break;
					}
				}

				// Check for control codes like <name>
				if (substr.StartsWith('<') && substr.EndsWith('>'))
				{
					foreach (var kvp in table.ControlCodes)
					{
						if (kvp.Value == substr)
						{
							result.AddRange(kvp.Key);
							pos += len;
							matched = true;
							break;
						}
					}
					if (matched) break;
				}

				// Check reverse mappings
				if (table.ReverseMappings.TryGetValue(substr, out var bytes2))
				{
					result.AddRange(bytes2);
					pos += len;
					matched = true;
					break;
				}
			}

			if (!matched)
			{
				// Single character not found - skip or error
				pos++;
			}
		}

		return result.ToArray();
	}

	public IEnumerable<TextBlock> FindTextBlocks(byte[] data, TableFile table, TextSearchOptions? options = null)
	{
		options ??= new TextSearchOptions();
		var blocks = new List<TextBlock>();
		var start = options.StartOffset;
		var end = options.EndOffset > 0 ? options.EndOffset : data.Length;

		var currentBlock = new List<byte>();
		var blockStart = start;
		var validChars = 0;
		var totalChars = 0;

		for (int i = start; i < end; i++)
		{
			var b = data[i];

			// Check for end-of-string
			if (MatchesSequence(data, i, table.EndOfStringMarker))
			{
				if (currentBlock.Count >= options.MinLength)
				{
					var ratio = totalChars > 0 ? (double)validChars / totalChars : 0;
					if (ratio >= options.MinValidRatio)
					{
						var rawBytes = currentBlock.ToArray();
						blocks.Add(new TextBlock
						{
							Offset = blockStart,
							Length = rawBytes.Length,
							RawBytes = rawBytes,
							Text = DecodeText(data, blockStart, rawBytes.Length, table)
						});
					}
				}

				currentBlock.Clear();
				blockStart = i + table.EndOfStringMarker.Length;
				validChars = 0;
				totalChars = 0;
				i += table.EndOfStringMarker.Length - 1;
				continue;
			}

			// Check if valid character
			var isValid = table.SingleByteMappings.ContainsKey(b) ||
						  table.DteMappings.ContainsKey(b) ||
						  table.MteMappings.ContainsKey(b) ||
						  b == table.EndOfLineMarker.FirstOrDefault();

			if (isValid)
			{
				currentBlock.Add(b);
				validChars++;
				totalChars++;
			}
			else if (currentBlock.Count > 0)
			{
				// Invalid character - check if block is valid
				var ratio = totalChars > 0 ? (double)validChars / totalChars : 0;
				if (currentBlock.Count >= options.MinLength && ratio >= options.MinValidRatio)
				{
					var rawBytes = currentBlock.ToArray();
					blocks.Add(new TextBlock
					{
						Offset = blockStart,
						Length = rawBytes.Length,
						RawBytes = rawBytes,
						Text = DecodeText(data, blockStart, rawBytes.Length, table)
					});
				}

				currentBlock.Clear();
				blockStart = i + 1;
				validChars = 0;
				totalChars = 0;
			}
			else
			{
				blockStart = i + 1;
			}
		}

		return blocks;
	}

	public Script ExtractScript(byte[] data, IEnumerable<TextBlock> blocks, TableFile table)
	{
		return new Script
		{
			TableName = table.Name,
			Blocks = blocks.ToList(),
			Metadata = new Dictionary<string, string>
			{
				["ExtractedAt"] = DateTime.UtcNow.ToString("o"),
				["TotalBlocks"] = blocks.Count().ToString(),
				["DataLength"] = data.Length.ToString()
			}
		};
	}

	public string ExportScript(Script script, ScriptExportFormat format)
	{
		return format switch
		{
			ScriptExportFormat.PlainText => ExportPlainText(script),
			ScriptExportFormat.Csv => ExportCsv(script),
			ScriptExportFormat.Json => ExportJson(script),
			ScriptExportFormat.Atlas => ExportAtlas(script),
			ScriptExportFormat.Markdown => ExportMarkdown(script),
			_ => ExportPlainText(script)
		};
	}

	public Script ImportScript(string content, ScriptExportFormat format)
	{
		return format switch
		{
			ScriptExportFormat.Json => ImportJson(content),
			ScriptExportFormat.Csv => ImportCsv(content),
			_ => throw new NotSupportedException($"Import from {format} not supported")
		};
	}

	public IEnumerable<int> ReadPointerTable(byte[] data, int tableOffset, int count, int pointerSize = 2, int baseAddress = 0)
	{
		var pointers = new List<int>();

		for (int i = 0; i < count; i++)
		{
			var offset = tableOffset + (i * pointerSize);
			if (offset + pointerSize > data.Length)
				break;

			int pointer = 0;
			for (int j = 0; j < pointerSize; j++)
			{
				pointer |= data[offset + j] << (j * 8);
			}

			pointers.Add(pointer + baseAddress);
		}

		return pointers;
	}

	public byte[] WritePointerTable(IEnumerable<int> pointers, int pointerSize = 2, int baseAddress = 0)
	{
		var result = new List<byte>();

		foreach (var pointer in pointers)
		{
			var adjusted = pointer - baseAddress;
			for (int i = 0; i < pointerSize; i++)
			{
				result.Add((byte)((adjusted >> (i * 8)) & 0xff));
			}
		}

		return result.ToArray();
	}

	#region Private Methods

	private static byte[] ParseHexString(string hex)
	{
		hex = hex.Replace(" ", "").Replace("$", "");
		if (hex.Length % 2 != 0)
			return Array.Empty<byte>();

		var bytes = new byte[hex.Length / 2];
		for (int i = 0; i < bytes.Length; i++)
		{
			if (!byte.TryParse(hex.Substring(i * 2, 2), System.Globalization.NumberStyles.HexNumber, null, out bytes[i]))
				return Array.Empty<byte>();
		}
		return bytes;
	}

	private static string FormatHexBytes(byte[] bytes)
	{
		return string.Join("", bytes.Select(b => $"{b:x2}"));
	}

	private static bool MatchesSequence(byte[] data, int offset, byte[] sequence)
	{
		if (sequence.Length == 0 || offset + sequence.Length > data.Length)
			return false;

		for (int i = 0; i < sequence.Length; i++)
		{
			if (data[offset + i] != sequence[i])
				return false;
		}
		return true;
	}

	private static string ExportPlainText(Script script)
	{
		var sb = new StringBuilder();
		sb.AppendLine($"// Script: {script.GameName}");
		sb.AppendLine($"// Table: {script.TableName}");
		sb.AppendLine($"// Blocks: {script.Blocks.Count}");
		sb.AppendLine();

		foreach (var block in script.Blocks)
		{
			sb.AppendLine($"// ${block.Offset:x4} ({block.Length} bytes)");
			if (!string.IsNullOrEmpty(block.Label))
				sb.AppendLine($"// Label: {block.Label}");
			sb.AppendLine(block.Text);
			sb.AppendLine();
		}

		return sb.ToString();
	}

	private static string ExportCsv(Script script)
	{
		var sb = new StringBuilder();
		sb.AppendLine("Offset,Length,Label,Text,Comment");

		foreach (var block in script.Blocks)
		{
			var text = block.Text.Replace("\"", "\"\"");
			var label = block.Label ?? "";
			var comment = block.Comment ?? "";
			sb.AppendLine($"${block.Offset:x4},{block.Length},\"{label}\",\"{text}\",\"{comment}\"");
		}

		return sb.ToString();
	}

	private static string ExportJson(Script script)
	{
		var options = new JsonSerializerOptions
		{
			WriteIndented = true,
			PropertyNamingPolicy = JsonNamingPolicy.CamelCase
		};
		return JsonSerializer.Serialize(script, options);
	}

	private static string ExportAtlas(Script script)
	{
		var sb = new StringBuilder();
		sb.AppendLine($";; Atlas script for {script.GameName}");
		sb.AppendLine();

		foreach (var block in script.Blocks)
		{
			sb.AppendLine($"#JMP(${block.Offset:X4})");
			if (!string.IsNullOrEmpty(block.Label))
				sb.AppendLine($"; {block.Label}");
			foreach (var line in block.Text.Split('\n'))
			{
				if (!string.IsNullOrWhiteSpace(line))
					sb.AppendLine(line);
			}
			sb.AppendLine("#END()");
			sb.AppendLine();
		}

		return sb.ToString();
	}

	private static string ExportMarkdown(Script script)
	{
		var sb = new StringBuilder();
		sb.AppendLine($"# {script.GameName} Script");
		sb.AppendLine();
		sb.AppendLine($"**Table:** {script.TableName}");
		sb.AppendLine($"**Blocks:** {script.Blocks.Count}");
		sb.AppendLine();
		sb.AppendLine("| Offset | Length | Label | Text |");
		sb.AppendLine("|--------|--------|-------|------|");

		foreach (var block in script.Blocks)
		{
			var text = block.Text.Replace("\n", "<br>").Replace("|", "\\|");
			var label = block.Label ?? "-";
			sb.AppendLine($"| `${block.Offset:x4}` | {block.Length} | {label} | {text} |");
		}

		return sb.ToString();
	}

	private static Script ImportJson(string content)
	{
		var options = new JsonSerializerOptions
		{
			PropertyNamingPolicy = JsonNamingPolicy.CamelCase
		};
		return JsonSerializer.Deserialize<Script>(content, options) ?? new Script();
	}

	private static Script ImportCsv(string content)
	{
		var script = new Script();
		var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);

		// Skip header
		for (int i = 1; i < lines.Length; i++)
		{
			var parts = ParseCsvLine(lines[i]);
			if (parts.Count >= 4)
			{
				var offsetStr = parts[0].TrimStart('$');
				if (int.TryParse(offsetStr, System.Globalization.NumberStyles.HexNumber, null, out var offset))
				{
					script.Blocks.Add(new TextBlock
					{
						Offset = offset,
						Length = int.TryParse(parts[1], out var len) ? len : 0,
						Label = parts.Count > 2 ? parts[2] : null,
						Text = parts[3],
						Comment = parts.Count > 4 ? parts[4] : null
					});
				}
			}
		}

		return script;
	}

	private static List<string> ParseCsvLine(string line)
	{
		var parts = new List<string>();
		var current = new StringBuilder();
		var inQuotes = false;

		foreach (var c in line)
		{
			if (c == '"')
			{
				inQuotes = !inQuotes;
			}
			else if (c == ',' && !inQuotes)
			{
				parts.Add(current.ToString());
				current.Clear();
			}
			else
			{
				current.Append(c);
			}
		}

		parts.Add(current.ToString());
		return parts;
	}

	#endregion
}
