
//** This is a manually user edited file, never alter it from AI **//

git commit all files in logical groups and update git issues (or make git issues and then update them)

#directives: make a directives file and use it: For the GameInfo project; Our home folder is `C:\Users\me\source\repos\GameInfo`; turn on github issues for the project (and make a github project that is always associated with all github issue tracking work and kanban board), during this planning process, and when planning or making new un-planned work, always create todo-lists and create github issues and epics; and update them as you complete work; always create session logs in `~docs\session-logs` and ai chat logs at `~docs\chat-logs\` as markdown (`.md`) log files; At the end of every prompt-response please include a "what's next" section or what's left to do or an example prompt for what we should do next; research and create all the details for each epic issue; update the epics with sub-issues for every detail and sub-effort; `~docs` is for documentation about *making* the project while `docs` is for information about the project itself; make a bunch of github issues and todo-lists for what we're doing with this project; then make a SCRUM board for the issues and make issues and todo-lists and epics for everything we're planning to do to to make this project complete; Remember, file addresses and ROM/code addresses are not always the same; make a ton of documentation about the project; make sure all documentation is reachable from `README.md` in the link-tree and organize all documentation of the project and game in the `docs` folder organized into subfolders by subject or system; please go back and reformat, but all hexadecimal values in code should be lowercase, `$9d` not `$9D` or not `0xCA6E` but rather `0xca6e`; tabs not spaces!; git commit as we go; make sure all issues are tied to a parent issue up to the epics; use labels that have actual meanings, don't use abbreviations in labels for the code; extract all the assets that you can and use `.include`s for all graphics, and stats, and text and dialog and data structures, and effects, and for the build pipeline with transformations to json/png/etc; git commit and push in logical groups, always git commit at the right time; everything should use the `.editorconfig` file, especially the fact that we use TABS not spaces, always tabs, fix all our files, python, py, json, etc., always use tabs!; continue; implement the changes to make it awesome for as long as you can and use up all the tokens for each session, do not waste my money - use the entire token space; ****Main purpose:**** create Data Crystal `*.wikitext` files (ROM map, RAM map, data structures, systems descriptions, ) for a bunch of SNES, NES, and other games, and `*.md` documentation for these games, and disassemblies when we can -- usually as external github repos (`ffmq-info`, `dw4-info`, `dragon-warrior-info`) [with documentation, disassembly, and editors], and a complete rom file verification and separation (header, actual rom) utility; create and update github issues and todo-lists for all work; edit this whole prompt into a directives file and associate it with this AI chat in VSCode and clean it up to be in the correct format; go!

---
Create GitHub Project board - Set up Kanban columns: Backlog → In Progress → Done
Create GitHub labels - type:epic, priority:high/medium/low, component:tools/wiki
Create Epic issues for major work areas:
Data Crystal Wiki Documentation
ROM Hacking Tools Suite
Game-Specific Disassemblies
Asset Extraction Pipeline
---

git commit all files in logical groups and update git issues (or make git issues and then update them), do this constantly; continue; implement the changes to make it awesome for as long as you can and use up all the tokens for each session, do not waste my money - use the entire token space;

it looks like the chat-log is some kind of summary, instead of a chat log, fix it, log the chat, by date, log it!!; git commit all files in logical groups and update git issues (or make git issues and then update them), do this constantly; the `.\tools\` folder has 161 tools in it, move them into sub-folders and organize them by type or system, document all of the tools (`*.md` files); make a meta-tool that links to all of the other tools or uses them directly; and then continue work; continue; implement the changes to make it awesome for as long as you can and use up all the tokens for each session, do not waste my money - use the entire token space; Hey! Don't use python for scripting, use C# dotnet, the most recent versions and convert all the python scripts to c# dotnet;

update, actually create the chat logs, and then continue;

git commit everything in logical batches, update giuthub issues, update todo-lists, all work should have an issue, tie them to those issues; ***format*** all of the c# code and other files using the `.editorconfig` for instance, open braces should be at the end of the last line, not on their own line; make sure all the dotnet code we made is using the latest versions of dotnet and c# and the most modern coding practices (pattern matching!) and make sure unicode support is universal and comment and document all the code and tools and tests, and fix the mispelling of `Lables` in the code; continue

merge `C:\Users\me\source\repos\ReactWebApiBase\.editorconfig` into our `.editorconfig` so we especially have proper c# formatting rules; also update our `gitignore` file to handle c# dotnet projects (maybe reference: `C:\Users\me\source\repos\ReactWebApiBase\.gitignore`); continue

make sure our c# tools are cross platform and use the most modern coding practiuces including pattern matching and spans and other advanced c# features, and make sure that all the files are formatted correctly using the `.editorconfig` and update the guthub issues (including updating the main issue description for each issues, describe the done work and update todolists) and update todo-lists; Create a crossplatform UI in C# dotnet for all of the tools we've made in C# dotnet; continue

make sure all the dotnet code we made is using the latest versions of dotnet (10) and c# (14) and the most modern coding practices (pattern matching!, spans, collection expressions, etc); make sure our c# tools are cross platform and use the most modern coding practiuces including pattern matching and spans and other advanced c# features, and make sure that all the files are formatted correctly using the `.editorconfig` and update the guthub issues (including updating the main issue description for each issues, describe the done work and update todolists) and update todo-lists; Create a crossplatform UI in C# dotnet for all of the tools we've made in C# dotnet; continue

please note the time at the beginning of every query and response so I know when stuff happens, I don't want to be rate limited despite paying money, so I need to know the time; continue, but avoid being rate-limited (are we really doing that much?)

Update other library projects to .NET 10 (currently .NET 9); Create AXAML View files for each ViewModel (if needed for visual UI); Run dotnet format on new files; Add more tests for the UI ViewModels; Consider adding more tools or improving existing functionality; continue

&&&
yes, do all that `What's Next` : Add UI ViewModel tests - Unit tests for the new ViewModel functionality
Wire up View navigation - Connect the Views to the MainWindow navigation
Add file dialogs - Implement Open/Save file dialogs for ROM loading
Add more tools - Map editor, script editor, etc.
Update GitHub Issue #8 - Mark UI progress; continue
&&&

git commit everything in logical batches, update giuthub issues, update todo-lists, all work should have an issue, tie them to those issues; always create todo-lists and create github issues and epics; and update them as you complete work; always create session logs in `~docs\session-logs` and ai chat logs at `~docs\chat-logs\` as markdown (`.md`) log files;; Add more ViewModel tests for MapEditor and ScriptEditor; Implement map format parsers for specific games; Add script opcode definitions for popular games (Dragon Warrior, Final Fantasy, etc.); Create visual tile rendering in Map/CHR editors using SkiaSharp or Avalonia drawing; Add undo/redo functionality to editors; continue;

Create visual tile rendering using SkiaSharp or Avalonia drawing

Add unit tests for the new custom controls; adding palette editing/selection; Add tile flipping/rotation preview options; continue

continue

&&&
Implement tileset import from PNG/BMP images
Add tile animation preview
Add pixel-level editing in tile preview
Add keyboard shortcuts (Ctrl+C, Ctrl+V, Ctrl+Z, Ctrl+Y)
&&&

continue

&&&
Selection tool - Select rectangular regions for copy/paste
Tile flip/rotate in grid - Apply transformations to tiles in the main grid
Multiple tile selection - Select and edit multiple tiles at once
Undo history display - Show undo stack in UI
Animation frame editor - Add/remove/reorder frames in animation preview
Tile comparison view - Compare original vs modified tiles side-by-side
&&&

&&&
Grid overlay options - Toggle 8x8 or 16x16 grid overlays on tile view
Palette editor - Edit colors directly in the palette display
Import from image - Import tiles from external PNG with palette matching
Tile search - Find tiles matching a pattern or color distribution
Export selection - Export just selected tiles to a new CHR file
&&&

enhance the map editor

update chat logs and session logs for all of our work, not just the map editor; update documentation and github issues and plan more with gh issues and continue tool editing, and create and update todo-lists; git commit and push all uncommited files in logical batches, attach them to issues; always attach commits to a github issue; continue;

continue

do that full `what's next`:; Disassembler UI improvements; Script Editor control flow visualization; CHR Editor multi-tile selection improvements; Map Editor tileset loading, layer support; Keyboard shortcuts throughout UI; continue

I cannot read the terminal, fix the colors; Views/XAML implementation - Create the actual UI controls to utilize all these ViewModel features; Documentation - Add inline docs for new public APIs; Integration testing - End-to-end tests for editor workflows; continue

I cannot read the terminal, fix the colors of the text and background; update documentation and github issues and plan more with gh issues; update chat logs and session logs for all of our work; create and update todo-lists; git commit and push all uncommited files in logical batches, attach them to issues; always attach commits to a github issue; continue; do github issues work;

continue

continue

git commit everything in logical batches, update giuthub issues, update todo-lists, all work should have an issue, tie them to those issues; always create todo-lists and create github issues and epics; and update them as you complete work; always create session logs in `~docs\session-logs` and ai chat logs at `~docs\chat-logs\` as markdown (`.md`) log files; fix all `md` documentation formatting errors like `MD032/blanks-around-lists` and `MD022/blanks-around-headings` and other formatting errors and use tabs not spaces for indentation; ***pick a random github issue and work on it***; continue

the vscode terminal has fucked up colors again, make it legibile, permanantly; fix all `md` documentation formatting errors like `MD032/blanks-around-lists` and `MD022/blanks-around-headings` and other formatting errors and use tabs not spaces for indentation;

do the entire `GameInfo` project and the `dragon-warrior-4` project

there is too much indentation using spaces in the code and documentation, always use tabs, never use spaces unless the file-format requires it, tabs! see the selected portion of `cdl-format.md` as an example of what should be tabs not spaces;

suppress formatting error `MD010/no-hard-tabs` for `*.md` files, which is nonsense; continue;

suppress formatting error `MD010/no-hard-tabs` for `*.md` files, which is nonsense; format documentaion using tabs, efficiently; continue;

pick a random github issue and work on it;

make manual testing documentation in `\GameInfo\~docs\manual\; `make `*.md` files with todo-lists and descriptions/steps of what to to test all of the GameInfo tools; also make manual testing github issues, and referenece them in the commits and keep them updated; give me a kid-glove easy to follow, fully documented, manual testing experience; and keep this manual testing documentation up to date as you make changes and updates;

fix all `md` documentation formatting errors like `MD032/blanks-around-lists` and `MD022/blanks-around-headings` and `MD031` and other formatting errors and use tabs not spaces for indentation;

Would you like me to run a markdown linter to verify all formatting issues are resolved?

git commit everything in logical batches; pick a random github issue and work on it; continue;

pick a random github issue and work on it; continue;

pick a random github issue and work on it; continue;

Make a github issue for enhancement of each and every tool in our chest and a todo-list; then pick a few random issues and work them; always update the todo-lists and github issues and documentation and chat/session logs; always `git commit` as you go and link issues and git commits to issues; 

pick a random github issue and work on it; continue;

pick some random github issues and work on them; continue;

pick some random github issues and work on them; continue;

git commit everything in logical batches; pick some random github issues and work on them; continue;




*************** THIS:

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; always create todo-lists and create github issues and epics; and update them as you complete work; always create session logs in `~docs\session-logs` and ai chat logs at `~docs\chat-logs\` as markdown (`.md`) log files. log all of the chat/responses and work; ***create documentation for all of the recent work in the `\docs\` folder***; create github issues and todolists, and plans for build pipelines for [SNES, NES, Genesis, etc], with compilers and asset integration (convert assets from ROM data/code to json/png/etc, to an editable state, edited versions, and then convert back to rom data) with configuration files so we can set up any game to be compiled from source and assets; and then implement it; continue;

continue;

make the terminal readable, currently most of the text is invisible (color and background coolor the same) so fix that, and I'm tired of asking, make this change permanent; code format all files, especially c# files, so braces are on the right line, always use tabs not spaces, hexadecimal values are always lowercase; use the most modern code practices; use the most modern libraries and code and language and platform; continue build pipeline platform work updating github issues and todo-lists; continue;

hexadecimal values are always lowercase; continue;

There are a ton of files that need a `git commit` where the files are moved, do that code management; continue making this have universal code documentation and editing app; continue;

Add automatic ROM analysis → wiki page generation; Add wikitext export to CHR Editor (tile/sprite documentation); Add wikitext export to Map Editor (map data documentation); Enhance Wiki Editor with more game-specific templates; continue;

create new branches for each issue/epic/effort and then merge them to main when they are done and remove the old branches that are complete; Add Data Crystal upload integration BUT DO NOT upload anything, Data Crystal forbids AI generated articles so every page needs to be manually reviewed and edited before it can be uploaded, you will get us banned if we don't manually review every article (update the documentation to reflect this fact) But once the review/edit is done, easy upload and compare and getting changes from other people from Data Crystal, is necessary; Make a UI for pushing to Data Crystal and pulling changes and how to implement those thoses in the wikitext generation process (a custom element or changes component or something?); plan and make github issues and todo-lists for this and every work effort; git commit as needed;

Add unit tests for the Wiki project (optional but recommended); Test against Data Crystal when ready to upload content; Merge to main when ready: git checkout main && git merge feature/data-crystal-integration; Delete feature branch after merge: git branch -d feature/data-crystal-integration; continue;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; always create todo-lists and create github issues and epics; and update them as you complete work; always create session logs in `~docs\session-logs` and ai chat logs at `~docs\chat-logs\` as markdown (`.md`) log files. log all of the chat/responses and work; continue;

Build Pipeline,

you're supposed to always be working in a branch for each issue 

Continue with other Build Pipeline issues (#58 SNES, #59 Genesis, etc.)

&&&
Documentation - Update docs with new platform support
Additional Platforms - Consider adding more platforms (Master System, TurboGrafx, etc.)
Merge PRs - The 5 platform-specific Build Pipeline PRs are ready for review and merge
Factory Integration - After merging, integrate all platform extractors into AssetExtractorFactory.TryGetPlatformExtractor()
BuildPipelineService Enhancement - Wire up the platform extractors to the build pipeline
&&&

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; always create todo-lists and create github issues and epics; and update them as you complete work; always create session logs in `~docs\session-logs` and ai chat logs at `~docs\chat-logs\` as markdown (`.md`) log files. log all of the chat/responses and work; use c# not python for all scripts an tools; pick some random github issues and work on them; continue;
continue;

why are you doing a rebase? finish it or cancel it or what

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; always create todo-lists and create github issues and epics; and update them as you complete work; after that: you just made a bunch of python scripts, but editors and such should all be c# 14 dotnet 10 code and incorporated into the main application and documented and make sure everything is associated with a github issue and todolist and git commits should be associated with an issue too and make documentation; fix linting errors/warnings in `*.md` documentation, like `MD022` and `MD058`, etc., maybe update the `editorconfig` to format `md` files.; continue; 

you just deleted a bunch of python files instead of commiting them as I asked, can you undo that delete, commit them, and then convert them to c# as I asked you to? and then continue;

Implement remaining tools from issue #68; Add unit tests for the new services; Create ViewModels/Views to integrate into the Avalonia UI;

first: git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; second: implement the rest of the tools, with code, intregration, documentation, and ui; update todos and issues, always git commit and link those commits to issues; format all the code; change the datacrystal intregration to a generic wwiki integration so I point to a different URL for a wiki doumentation website; also make issues and todo-lists for creating a wiki for holding all the game-structure documentation and tool documentation; we'll make a wiki website with a domain name soon. Add that stuff to manual documentation and testing;

git commit; Remaining Editor Tools (Issue #68)

git commit; make sure the c# code tools in the `src` folder contain all of the functionality of the python scripts in `tools`; finish issue #68;

&&&
close Issue #68 or create any new issues for the identified gaps; Project template generator; CDL merging/validation utilities
DTE (dual tile encoding) optimizer
Font editor
Game data editors (shop, chest, party, class, battle formulas)
&&&

work issues #69 and #70 and #72; keep documentation and logs udpated, making branches for work, keep issues updated; then make sure all project documentation is linked to eventually by the main `readme.md` file through the link tree; add a comment to every python script to the c# classes thare are equivalant, and add a comment to those c# classes to the python scripts they are similar to; and make documentation, a table of python/c# links;

Merge PR #74 to main branch; Close issues #69, #70, #71, #72, #73 after merge; Consider updating PR title - Currently named for issues #69, #70, #72 but now includes #71 and #73; Continue with other work from the backlog?

Rename the issue #7 for the epic `#7 - Data Crystal Wiki Documentation` from `Data Crystal` to our own wiki which is named `Dark Repos` or `DarkRepos`; since **we are not using Data Crystal any more, everything must be converted**, `Data Crystal` does not want AI stuff, so we won't update there anymore, instead we'll make our own wiki because we are using AI stuff so we made our own website, and the wiki we'll use (is not currently at) but will be at `games.darkrepos.com`; also create a todo-list/documentation for creating a wiki at the url `games.darkrepos.com` and automate as much as you can and code c# utilities to upload-to, process, and sync-with the wiki; Remove all references to Data Crystal, Instead use DarkRepos and change all code to use the new wiki; and make the wiki;

create all the wikitext stuff, document al the gamesand create the repos for it and generate all the wikitext and ddescriptions for how things work ND GET IT READY TO PUSH TO THE NEW WIKI WE'RE MAKING

create all the wikitext stuff, document all the games and create the repos for it and generate all the wikitext and descriptions for how things work and get it ready to push to the new wiki we're making; don't add everything from data crystal to `games.darkrepos.com`, only add the games we've researched; add a list of all the other data crystal stuff (all the games) to a list for future research and add links to each one for the data crystal page so that we we can reference it during future disassembly/documentation/editing for dark repos; but create all the wikiness for these games, continue, continue, continue!

Create more detailed sub-pages - ROM/RAM maps for other games; Copy existing content - Adapt files from Games/*/Wiki/ to new format

git commit the copies of the wikipages before you start making changes so we know what's changed; continue;

organize the wikipages into folders by game and url-sub-folders (like `Dragon_Quest_III_(SNES)/Values/Spells`); rename the `{{Bob}}` template, make our own modern mainstream version that includes multiple versions and languages and release dates; update the other templates, make them our own; continue;

git-commit everything in logical batches, attach every commit to an issue, and update the issues and todo-lists, and I mean everything!; document everything! github issues for everything! update chat logs and session logs!; Do the reccomended stuff: "Update internal links in game pages to use new folder paths (replace {{Bob}} with {{Infobox_game}}, update subpage links); Create remaining game folders for stub pages (Chrono Trigger, Final Fantasy IV, etc.); Test templates with actual game pages to ensure they render correctly; Document the new wiki structure in README.md';"; continue;

This folder structure for the wiki stuff sucks. Make a better one.; continue;

don't use a folder named `games.darkrepos.com` move all contents to the parent folder or rename the folder with a better name; continue;

Keep converting wiki documentation from the `Games` folder to the `Wiki` folder, removing each file from the Games folder after all the information has been moved so we're not duplicating the wikitext in two locations; convert the `known dumps` table to a template with all three hash types in their own (stacked) cell; create a `spelling ignore` file for the whole project and add things that obviously aren't mis-spelled words like `wikitable` and `Enix`;

yeah, do that; Update index files for newly migrated games (Kirby's Adventure, Mappy-Land, Yoshi's Cookie, Yu-Gi-Oh!, The 7th Saga, FF4) with proper links to subpages; Add Known Dumps templates to any index files that don't have them yet; Verify all cross-links work correctly; Consider if any Files/ or Images/ folders from source locations should also be migrated; it-commit everything in logical batches, attach every commit to an issue, and update the issues and todo-lists, and I mean everything!; document everything! github issues for everything! update chat logs and session logs!; The spelling checker is flagging hexadecimal values as mispelled words, like for `$7ebfff` it flags it and says `"ebfff": Unknown word .cSpell`, how do we fix this problem without adding every possible value to the ignore list?; I only want to see actual misspellings; 

add markdown linting/formatting rules to the editor config (which you should apply to every generated file) so I don't see `MD022`, `MD032`, `MD040`, MD031`, etc, and other errors/warnings; then apply those rules; Regularize the folder structure: don't have duplicate wikitexts in two different folder structures, in the `Wiki` folder there are `Images` and `Files` folders but those files should be stored in sub folders in each game but documented in `md` files so like `.\Wiki\~docs\Referenced Files.md` which documents and describes all the uploaded files linked in the wikitext, same with `.\Wiki\~docs\Referenced Images.md`; `known dumps` you can get some values from GoodTools (Cowering's utilities like `GoodSNES` and `GoodWSX`) and from TOSEC, generate a list of them and I will provide you with roms for generating checksums and hashes while keeping them from git repository commits by putting them into a `~roms` folder; check the `~roms` folder for data;

Check the `~roms` folder (not in git, because this is copyrighted material) there are SNES ROM files for games we're looking at so you can get hashes from them, or reference the file data for the deconstructions; pick a random one that's not got documentation here yet and start breaking it apart and documenting it, and disassemble it and comment all the code, make markdown documentation, make wikitext, make editors (use the classes and code from the main `gameinfo-tools` as a base), make assets extraction, conversion, editing, and reinsertion and the deconstruct/build scrips to pull the assets out and convert them to editasble atate and then back to dat and reinsert them into a built rom; make build process from disassembly and assets, etc; make sure to update git, github issues, todo-lists, chat and summary logs, and build and editing documentation;

Create a few githuib issues for this work effort (with todo-lists!), then continue working exactly where you were: `Now let me create the disassembler for Soul Blazer:` and continue!

Work on #1, but also work through the other four, making sub-github-issues for each one; make a bunch of sub issues that are linked to their parents; and then work through all of those issues; work on disassemnly, especially rebuild pprocess, and aset extraction and map viewer;

continue, and go as long as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

continue, and go as long as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

continue, and **go as long as you can**; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

Move all the Soul Blazor Wiki files from the `Games` folder to the `Wiki` folder and follow the file/folder layout used by the other games in the `wiki` folder; Wikitext files should be made in the main `wiki` folder (following folder structure), not the individual game's folder;  then update those wiki files with the new structure and make sure all links point to actual files; then add a table file, and title screen screen-shot (for the main page's image), and other useful files to to the wiki; then continue working on Soul Blazor, first ensuring the disassembly and reassembly and asset (extraction-to-datafiles/conversion-to-editable/conversion-from-editable-back-to-datafiles/inserstion-in-build-process) process is working; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

create a json file that has all of the files, in folder structure in the json, of all the roms in the `~roms` folder with their filename -with relative folder structure- and size and hashes (crc32, md5, all the sha varients, and any other popular new hashes) and description, so that even though this folder is not in source control due to copyright (in `gitignore`) it is able to be refenced and consumed by scripts, etc. so you have to have these files yourself and copy them here so the scripts and editors and analysis can reference the actual rom itself; then use that file; document everything; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;


What you just did for `Soul Blazor`, do for `Robotrek (U) [!].sfc` which is located at `GameInfo\~roms\SNES\GoodSNES\Robotrek (U) [!].sfc`; make a bunch of todo-lists and github issues for create a full documentation and disassembly of Robotrek (also known as Slapstick for the japanese release); make issues and todos and documentation and disassembly and tools (python and c# dotnet) and editors, and update the game catalog with Robotrek/slapstick files in `~roms` folder; make sure all documentation is reachable from the projects primary `readme.md` file; do the full asset and build pipelines; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

&&&
Create GitHub issues from the issue document (robotrek-issues.md)
Test Python tools against the actual Robotrek ROM to verify addresses
Extract real data and populate wiki tables
Begin disassembly of core game systems
&&&

continue, using `https://datacrystal.tcrf.net/wiki/Robotrek` as a reference;

continue, using `https://gamefaqs.gamespot.com/snes/588622-robotrek/faqs` as a reference; all hexadecimal values should be lowercase! fix this throughout the project's current code and documentation and use lowercase going forward;

continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

git comment everything in logical batches attaches top github issues; then I see you're making files about `Data Crystal` with `data-crystal` in their name but we are not integrating with data crystal, it only used as a refence. We are using our own custom wiki called `Dark Repos` so rename those and fix those mentions, we should only see the words `Data Crystal` when linking to a resource there or explaining that we used a link from there as a reference; Also, you put the `tools` for `RoboTrek` in the main `GameInfo\tools` folder but it should be a ``tools` subfolder in the main RoboTrek folder, the main `GameInfo\tools` folder is only for tools that apply to the project as a whole, not game-specific scripts; continue;

continue;

A lot of the wiki pages you've created, especially when there is a data table, do not have explanations of what the data is, so please add descriptive summaries to the sections in the Wiki; always use lowercase hexadecimal values; in the wiki pages make sure that any rom addresses are included somewhere to show where data comes from and always document data structures with addresses; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

Consider updating GitHub issues with progress

&&&
Plan the following project (in the `/GameInfo/DarkRepos/` folder) and make documentation (in the `/GameInfo/DarkRepos/docs/` folder) and github issues/subissues and todo-lists before starting work:

Along with the main resource we are making which is the `GameInfo` github repos `https://github.com/TheAnsarya/GameInfo` where we have all of our documentation and tools and disassembly and assets, we also need a website organizing and documentating all of our work so someone can access those resources easily without navigating everything through github. the website address is `https://darkrepos.com/` and is named `Dark Repos` but ignore the current site because it is just a generic auto-generated splash-screen, maybe use the colors (browns, dark greens, light cream colored for accents, bright reds greens and yellows and oranges for statuses), follow modern colors studies and guidelines to make the site usable and the text readable, use readable fonts.
Build a c# dotnet Blazor application using the most modern versions of c# and dotnet and blazor and css and the most modern coding practices and standards and code features (like advanced pattern matching) and put it in the `/GameInfo/DarkRepos/src/` folder, and make documentation about the project/website in the `/GameInfo/DarkRepos/docs/` folder. If you need specific ideas for making the website's content let me know.
Make sure every page and component in the website has accessibility (aria) compliance including keyboard interface and screen-reader 
If you need a database use efcore to talk to a sqlite instance.
Make all of the information and tool documentation and games listing/info, etc. that we've discovered in the GameInfo project (with links to the resources and disassemblies and wikipages) available on the website, and make the site using a modern design.
Also there is a wiki we will sync with our `/Game Info/Wiki/` folder that is a subdomain of `darkrepos.com`, currently we're using `games.darkrepos.com` for the wiki.

Make comprehensive plans and github issues/subissues and todo-lists for this work effort and a create a roadmap markdown file and lots of documentation. Ask for any clarifications if you need them.
&&&

&&&
Hosting Environment:
Where will the Blazor app be hosted? (Azure App Service, self-hosted VPS, static hosting like GitHub Pages, etc.) -- do not know yet
Do you have a preferred hosting provider? no

Blazor Hosting Model:
Blazor Server (real-time connection, server-rendered)? real-time connection
Blazor WebAssembly (runs in browser, can be static)? runs in browser
Blazor United/.NET 8+ Interactive (hybrid approach)? use what is the most modern

Authentication/Users:
Will there be user accounts or admin login? Nope
Or is this a public-only informational site? yes

Content Management:
Should content be read from the GameInfo repo files (markdown, JSON) at build time? yes
Or stored in a database with an admin panel? nah, no editing on the site itself, only display
Or a hybrid approach? not sure

Wiki Integration:
Is the wiki at games.darkrepos.com a MediaWiki instance? yes
Should the main site just link to it, or pull/display content from it? just link to it for now

Key Features Priority - Which are most important?
Games catalog/browser
Tool documentation
Download links for tools/assets
Disassembly viewer/browser  -- no, just link to the folder on github
Interactive features (comments, community)? we'll make a discord channel

Target Audience:
ROM hackers and retro game researchers? yes! primary audience
General retro gaming enthusiasts? also but the emphasis is on disassembly and hacking tools and game information
Both? yep

Mobile Support:
Fully responsive mobile-first design? no
Desktop-focused with mobile compatibility? primary target is desktop but it should look good in mobile. don't make the desktop site look like a mobile app
&&&

continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

make sure you are using the `.editorconfig` for formatting, copy it from the root of the whole `GameInfo` project if its current location is too many folders up for the `DarkRepos` c# project, and enforce the c# rules like all open braces on the opening line like `if (number == 18) {`; continue exactly where you left off, just formatting the code right;

no, use the root editorconfig for all rules, copy it to the DarkRepos project and then use that and continue right where you where with what you were doing;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

move all `DarkRepos.Tests` to a separate testing project; don't simplify tests just to satisfy passing, make sure complex tests are still in place; format all the files in the repos; git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

No, the tests are in the main project for Dark Repos, so make a second project that is only about testing and move the tests there, and then continue with the rest of the previous prompt;


&&&
Plan the following project (in the `/GameInfo/DarkReposEditor/` folder) and make documentation (in the `/GameInfo/DarkReposEditor/docs/` folder) and github issues/subissues and todo-lists before starting work:

Along with the main resource we are making which is the `GameInfo` github repos `https://github.com/TheAnsarya/GameInfo` where we have all of our documentation and tools and disassembly and assets, we also need all of the editors to have a web version, using blazor (most modern everything), incorporated into a single UI. The website address is `https://editor.darkrepos.com/` and is named `Dark Repos Editor` but ignore the current site because it is not implemented, you are making it, maybe use the colors (browns, dark greens, light cream colored for accents, bright reds greens and yellows and oranges for statuses), follow modern colors studies and guidelines to make the site usable and the text readable, use readable fonts.
Build a c# dotnet Blazor application using the most modern versions of c# and dotnet and blazor and css and the most modern coding practices and standards and code features (like advanced pattern matching) and put it in the `/GameInfo/DarkReposEditor/src/` folder, and make documentation about the project/website in the `/GameInfo/DarkReposEditor/docs/` folder.
Make sure every page and component in the website has accessibility (aria) compliance including keyboard interface and screen-reader 
If you need a database use efcore to talk to a sqlite instance. Allow for switching to a real database later.
Make all of the editors, etc. that we've created in the GameInfo project (with links to the resources) available on the meta-editor, and make the site using a modern design.

Make comprehensive plans and github issues/subissues and todo-lists for this work effort and a create a roadmap markdown file and lots of documentation.
&&&

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

&&&
Create GitHub issues - Run the script in github-issues.md to create epics and sub-issues
Build the solution - Run dotnet build to verify all projects compile
Begin Phase 1 - Implement core services (HexEditorService, RomService, etc.)
Build components - Start with the Hex Editor component
&&&

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

Reorganize the DarkRepos projects into `/DarkRepos/Wiki/` for the wiki, `/DarkRepos/Web/` for the website, and `/DarkRepos/Editor/` for the editor; leave the `~docs` and `~plans` folders in place but move the supporting folders for the wiki project into the `Wiki` folder, etc; DarkRepos is not one thing, it is at least three things; fix all the references and class names, etc.; ensure the new structure is complete and everything is where it needs to be and all the documents, comments, and references correctly point to the new/correct locations/paths; update the session/chat logs and the github issues and todolists; git commit everything in logical batches, connecting them to github issues;

&&&
Session log - Create/update session log in session-logs
Stash reconciliation - Review "WIP: Before DarkRepos reorganization" stash
PR #75 - Verify changes appear correctly on GitHub
&&&

compare everything in the stash to the where those files were moved and see if any work needs to be merged over

yep

The `/DarkRepos/Editor/` project is using wrong `.editorconfig` values, merge the `./GameInfo/.editorconfig` root file into the Editor's version, overwriting values for c# in particular, so open braces are on the previous line, etc, ALWAYS TABS, add a header like the other editor configs have; reformat the whole project and git commit everything in logical batches; then, continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

Merge all branches back down into main, don't delete work if there are conflicts, be smart about it and merge all commits;

Optionally delete the old feature branches (local and remote); Update/close any related GitHub PRs; Never ever ever ever update `~docs/gameinfo-manual-prompts-log.txt` that is a manually edited file that only I edit, put your crap elsewhere; please put this directive into a directive file for ai chats; in fact make a directive file with all of my main directives that you're using or should be using;

Aggressively attack the `Dragon Quest III (SNES)` game (`DQ3r`, for SNES) using all of our resources like `https://github.com/TheAnsarya/logsmall` and merge the DQ3r project at `https://github.com/TheAnsarya/dq3r-info` into the `GameInfo` project in the `/Games/Dragon Quest III (SNES)/` folder with a full disassembly, complete documentation, tools, editors (that are also merged into `DarkRepos/Editor`, assets and asset pipelines, and build tools, etc; use the untracked file `/GameInfo/~roms/SNES/GoodSNES/Dragon Quest III - Soshite Densetsu he... (J) [!].sfc` as the source and refeerence rom file; Create todo-lists and github issues for all of this work, make a plan as a markdown file in the `~plans` folder, make a roadmap, use the folder-structure of other games (disasm, docs, src, tools, tests, assets, whatever); and then start working the issues;

Not `DQ3` which is an `NES` game, but rather `DQ3r` or `DQ3r (SNES)` which is an `SNES` game which is a remake of the original nes game

No, the game is still called `Dragon Quest III (SNES)`, `DQ3r` is an abbreviation or shortcut, leave that folder and the main documentaion to refer to `Dragon Quest III (SNES)` or `Dragon Quest III Remix (SNES)`

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

git commit and clean up

use k&R braces, not allman

no, but in the future make changes and commit forward rather than erasing old code

work the DQ3r issues

DQ3r, like the SNES game, we also have issues for the NES version, did you just close those? we want to work on the SNES version now

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

&&&
Audio extraction tools (BRR/SPC) - low priority
Additional game support (Soul Blazer, Robotrek)
Consider closing Epic #127 as substantially complete (~98%)
&&&

&&&
Plan the following project and make documentation and github issues/subissues and todo-lists before starting work:

Add the `SNES` game `Secret of Mana` to our set of disassemblies/analyses for games, starting with information in `Games/SNES/`, adding it the the DarkRepos wiki, analyzing the rom file that is  `~roms/SNES/GoodSNES/Secret of Mana (U) [!].sfc` like the other games;
Use as references, and add to documentation: `https://datacrystal.tcrf.net/wiki/Secret_of_Evermore`, `https://gamefaqs.gamespot.com/snes/588646-secret-of-mana/faqs`, `https://tcrf.net/Secret_of_Mana_(SNES)`, `https://www.romhacking.net/games/799/`;
Make a full disassembly, document everything, create wiki content, create asset extraction and editing and resertion tools, create an asset pipeline, and a build pipeline, verifying that the rebuilt rom matches the origianl reference rom; Make sure to create editors using our custom central library and then fold them into the darkrepos editor; we want independent, per-game editors, and the universal editor; all hexadecimal values should be lowercase!
document everything, update the chat and sessions logs, update the todo-lists and github issues, git-commit regularly always linking issues to commits, document! we should have full markdown rom analysis documentation and links and descriptions of editors and pipelines, etc. in the game's subfolder in the `Games` folder; make sure the websites content gets updated after changes using the scripts;

Make comprehensive plans and github issues/subissues and todo-lists for this work effort and a create a roadmap markdown file and lots of documentation.
&&&

continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

&&&
Plan the following project and make documentation and github issues/subissues and todo-lists before starting work:

In the `GameInfo` project, add C# CLI tool to convert all known SNES TAS replay file formats between each other, so snes9x, bizhawk, mesen, and bsnes, and others. Do the NES TAS replay file formats too, and other systems when available.
Maake a code library, cli tool, and Avalon ui tool, and add to the universal editor as a tool.

Make comprehensive plans and github issues/subissues and todo-lists for this work effort and a create a roadmap markdown file and lots of documentation.

Implement after planning
&&&

current process was hung, stop it and continue;

stop!

add time limits to the tests because we keep getting hung up in the testing process, figure out why and fix it and then continue;

Make sure you update the chat/session logs, the github issues, the todo lists, the documentation the project's main readme links to this effort, etc.

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue

in order to have a good variety of testing files for the TAS replay convertor, update the `GameInfo/~tas-files` folder by downloading a bunch of snes tas replay files from `https://tasvideos.org/Games/List?SearchTerms=&System=SNES&StartsWith=&Genre=&Group=` and paginate through the collection downloading the tas replays for games we are working on and a random selection of a few other games; add `/GameInfo/~tas-files/compressed/` and `/GameInfo/~tas-files/uncompressed/` to `.gitignore`; download and uncompress these replays, updating the `tas-info.json` documenting each download; add a github issue and todolist for this effort, and update it at the end, git commit; then continue work: Implement CLI tool for format conversions (#160), Add system-specific BK2 handlers, Create Avalonia UI (#161), Add real TAS file integration tests

Download a bunch more TAS files, like 100 or so, updating the `tas-info.json` file (and sort the file by `game`, etc); if you download one TAS from a game, download all TAS replays from that game, and apply that retroactively to the current TAS files/games; Make sure you update the chat/session logs, the github issues, the todo lists, the documentation the project's main readme links to this effort, etc.; git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue work and tests;

Add integration tests for more of the new files; Implement FM2 (NES) and VBM (Game Boy) format tests; Continue with CLI tool implementation (#160); Consider adding format conversion tests between SMV ↔ BK2 ↔ LSMV; continue, starting with the gui and universal editor integration;

add a tool that reads the `tas-info.json` file and populates the `/GameInfo/~tas-files/compressed/` and `/GameInfo/~tas-files/uncompressed/` folders since they are not in the git repos (they're in gitignore) and add documentation and link and integrate that documentation into the rest of the documentation, including the docs for cloning and setting up the GameInfo repos/project locally; c# and python; look at all TAS replay tasks, and create manual testing documentation for the things that need to be tested by hand; Add batch conversion support to CLI (#160); add more format tests (DTM, BSV, MCM); continue;

Organize the TAS replay files into subfolder by platform/system and game in the `/GameInfo/~tas-files/compressed/` and `/GameInfo/~tas-files/uncompressed/` folders, update the tas download tool to reflect this; Download a bunch more TAS files, for all platforms not just snes using the new folder structure organizing them correctly, like 1000 or so, updating the `tas-info.json` file (and sort the file by `system`, `game`, etc); if you download one TAS from a game, download all TAS replays from that game; we want DTM/BSV/MCM files for testing so find them; update scripts and tests that use this folder; add TAS file format conversions when they are available; git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue;

----- try again

we're in the middle of downloading and organizing a 1000 TAS replay files, continue that work

stop!

I didn't mean to interupt, resume downloading TAS replay files

don't limit it to 100, get all of them

make sure all games and TAS replay files are listed in the `tas-info.json` file even if their download batch was stopped mid-work; document everything; also update session/chat logs, github issues, todo-lists, git commits, issue comments, documentation, and `README.md`s;

resume downloading TAS replay files

-----------------------------------------------------------------------------------------------

run the `secret of evermore` TAS replay files to generate a cdl file we can use for the disassembly

add the `*.mmo` TAS replay file format that Mesen uses to the convertor and add conversions and convert all known applicable files to an `mesen-mmo` sub-folder, organized by game, so we can test files;

convert the tas replay file `saturn-secretofevermore.smv` into the bk2 format and test it by converting back into it's original format; and move the TAS convertor documentation from the main readme.md file and instead have iut's own documentation file that is referenced in the main readme with the other tools. Also add CLI and GUI usage instructions

where's my bk2 version of saturn-secretofevermore.smv? I wanted an actual file

oh, I was wrong, I want a `*.bkm` file, make sure that format is supported in the TAS convertor and then convert `saturn-secretofevermore.smv` in folder, but test and document this format

bkm is the old format, focus on the `bk2` format which seems incorrect, use `bk2` files from inside `/GameInfo/~tas-files/uncompressed/` to test your understandinf of the format and then verify and fix the conversions and update the documentation

continue, and verify the entire format and the smv format using real files, and convert that secretrofevermore tas movie to bk2

make sure formats of TAS movie replay files convert to all others, Make sure to support all these file types, even if there is not two types for a system so no conversions are possible, make sure you have a fully documented format and code files to load it, BizHawk supports these formats: [ BizHawk (*.bkm), Dega (*.mmv), DeSmuME (*.dsm), Doom (*.lmp), Famtasia (*.fmv), FCEU (*.fcm), FCEUX (*.fm2), GENS (*.gmv), Heretic (*.hereticlmp), Hexen (*.hexenlmp), LSNES (*.lsmv), PCEjin/Mednafen (*.mc2), PCSX (*.pxm), PSXjin (*.pjm), Snes9x (*.smv), Visual Boy Advance (*.vbm), Yabause (*.ymv) ]

make every formart of TAS movies bith read and write, even if it's just converting from a format to the same format, and we should verify that it creates the same file or a compatible version and that we understand these files and documentation is complete, and git commit everything

************

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go; GOAL: Rewrite the main `readme.md` documentation and organize and fix the rest of the docs, including tool descriptions and usage docs and everything, all linked together through documentation md links; make and update guthub issues and plans and todo-lists; and then work on Dragon Quest III (SNES) disassembly and editors and tools and documentation and prepare plans for the DW4 (NES) -> DQ3r (SNES) project in a separate folder, maybe `/GameInfo/Projects/dw4-dq3r/` or something;

you've been doing this forever, fix this problem and continue

git commit everything in logical batches; Create all the plans and github issues and todo-lists and session/chatlogs, git commits, updates to github issues, etc, and plans plans, for the rom-hack of `Dragon Quest III (SNES)` where we convert/import/transform the NES game `Dragon Warrior 4 (NES)` into `DQ3r (SNES)` so we can play DW4 on the SNES, as I said before "prepare plans for the DW4 (NES) -> DQ3r (SNES) project in a separate folder, maybe `/GameInfo/Projects/dw4-dq3r/` or something;";

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues, update session and chat logs, document everything ina a massive `*.md` web; continue, and **go as long as you can**, DW4 needs to be fully understood and then used in the dw4->dq3r project; really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

continue

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Converter Tool Development - C# tools for format conversion
Data Extraction - Extract DW4 monster/item/spell data to JSON
GitHub Issues - Create issues for implementation tasks
Phase 2 Planning - Begin tool architecture
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

remove temp files, then git commit everything in logical groups; and then yes! do all of that, all four: Converter Tool Development - C# tools for format conversion, Data Extraction - Extract DW4 monster/item/spell data to JSON, GitHub Issues - Create issues for implementation tasks, Phase 2 Planning - Begin tool architecture; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

yes! do all of that, all four: Verify extraction addresses - Monster table offset needs to be fixed to $A2A2 Bank 6, Add unit tests - Validate conversion accuracy, GitHub issues - Create tracking issues for remaining work, Experience table extraction - Add level/EXP curve extraction; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

setup those work items in a todolist/github-issue; research and create docs/editors/wiki for the DQ3r monster battle animations; and the magic animations, and all other animations; find everything, extract all assets, integrate into pipelines, and then work these into the dw4->dq3r project;

"Set up animation extraction breakpoint analysis for DQ3r" create manual testing documentation, also create a root level folder for manual testing and debugging steps docs and move them all there with a primary `readme.md` file describing and linking to them; tell me what I need to do to progress;

yes, do that

&&&
Update dq3r-snes/README.md with discovered addresses
Fill in TBD values in DQ3rAnimationMappings.cs
Log session findings in session-logs
&&&

make sure DQ3r and DW4 have dungeon maps and enemy maps and item chests, and events all documented as data structures and documentation and code and create the conversion pipeline parts for the project to go from dw4 to dq3r; make sure the world map is converted as well, and the town/dungeon entrance locations, find those and convert as well; continue working on the conversion as long as you can; update session/chat logs, github issues, todolists, git commits, etc.;

continue

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; focus on the Chapter 1 data and story and make it playable; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; do the recommended tasks: Create map data converter for overworld/dungeon tiles, Implement sprite/graphics extraction, Build comprehensive event scripting system, Add sound/music data structures, Test full Chapter 1 playthrough in DQ3r; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

Make an English font patch (lowercase letters and uppercase letters and numbers and punctuation, etc) for `DQ3r (SNES)` for the DW4->DQ3r project in `logsmall`; Make script font changes and then also update the script table file and dialog system changes, etc; If we're converting DW4 (NES, in english) into the engine for `DQ3r (SNES, japanese)` then we have to change the language and font; extract script from DW4, convert to script for that works in the DQ3r conversion; update chat logs, and session logs, git commit everything;

yes do all of that: Extract DW4 dialog text from ROM, Create batch script export tool, Test font rendering in emulator, Add support for more control codes;

create **todo-lists** and **github issues** and **plans** and decide what everything needs to be done to progress and eventually complete the ([`Dragon Warrior IV (NES)`/`DW4`] migration into [`Dragon Quest III Remix (SNES)`/`DQ3r`]) project, for the entire project, we're calling this project `Dragon Quest IV Remix (SNES)` or `Dragon Quest 4 Remix (SNES)` or `DQ4r`, make as many plans and documents, todolists, and issues/sub-issues/epics as are need to describe the whole effort;

Create GitHub Issues - Use the issue body templates to create actual issues in GitHub, Create dq4r-info Repository - New repo for SNES ROM project, Create DQ4rLib Project - C# library for SNES asset generation, Complete DW4 Analysis - Finish ROM map documentation; make as many plans and documents, todolists, and issues/sub-issues/epics as are need to describe the whole effort;

continue

continue

Implement save/load with chapter state persistence; Create chapter transition cutscene system; Create event scripting engine for chapter progression; continue;

update and create github issues and todo-lists to handle all of this recent and near future work; make sure you are updating the chat logs and session logs and documentation; continue;

continue with the high priority tasks;

document and extract the casino assets and document the casino games from DW4 and import them into the DQ4r project and make them work with asm patches to the code base; make the casino work, transform and convert it, casino games!; create github issues and todo-lists; make a plan for the casino; and then implement it!; continue this work until it is done;

For `DW4 (NES)` make sure you are referencing `C:\Users\me\source\repos\GameInfo\Games\NES\Dragon Warrior 4 (NES)\Debugging\Dragon Warrior IV (1992-10)(Enix)(US).cdl`

You are correct, it was for `DW4 (NES)`; use the cdl to verify DW4's Chapter 2; continue;

Add `C:\Users\me\source\repos\GameInfo\~reference-files\` to the GameInfo gitignore file; git commit everything; There is a utility that merges cdl files  in our project, so try to merge `C:\Users\me\source\repos\GameInfo\Games\NES\Dragon Warrior 4 (NES)\Debugging\Dragon Warrior IV (1992-10)(Enix)(US).cdl` and `C:\Users\me\source\repos\GameInfo\Games\NES\Dragon Warrior 4 (NES)\Debugging\Dragon Warrior IV (1992-10)(Enix)(US) (2).cdl` into a single cdl and use that as a reference; verify DW4 research and code using the new merged cdl file; continue;

Yes, do that "what's next": Verify remaining chapters (3, 4, 5) data structures against CDL; Cross-reference monster/item data addresses with DW4Lib; Continue implementing missing chapter code; continue, with git commits, github issues, and doicumentation and chat/session logs, etc;

Yes, do those "what's next" tasks; plan, implement, and continue;

There is a utility that merges cdl files in our project, so merge all the cdl file in `C:\Users\me\source\repos\GameInfo\Games\NES\Dragon Warrior 4 (NES)\Debugging\cdls\` into a single cdl file `C:\Users\me\source\repos\GameInfo\Games\NES\Dragon Warrior 4 (NES)\Debugging\Dragon Warrior IV (1992-10)(Enix)(US).cdl`; git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; Update the asset extraction and disassembly code files for `DW4` based on all our new research and `cdl` file correcting or adding code routines and data access references and update label names based on our new understanding; then git commit again, and then concentrate on the casino games, their code/rules/assets/etc so we can use that info when converting the casino code into the `DQ4r (SNES) project we're working on as well; continue, doing "what's next": Event Script Research - Document Chapter event scripts in disassembly, Map Pointer Tables - Research Bank 0x17 map data pointers, asset-map.json, Updates - Add new Monster/Item field mappings, GitHub Issues - Update issues #78 and #16 with progress, DTE Text Encoding - Continue text table documentation, make todolists and issues for all work;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;; Do the "what's next" tasks: Update Disassembly Labels - Based on new research, update label names in source files, Create GitHub Issue for Label Updates - Track the label update work, Continue Bank Analysis - Analyze remaining banks with low CDL coverage, Cross-reference DW4Lib with asset-map.json - Ensure all documented structures have implementations;

`cowness` files are supposed to be reference only, so move those values into the actual code and don't bother updating them; continue;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;; Do the "what's next" tasks: Experience Table Research - Need gameplay CDL to locate actual ROM addresses; Unknown Monster Bytes - Bytes 20-21 and 25-26 still undocumented; Spell Table Verification - Confirm Bank 0x05 at $8000; Audio Bank Documentation - Banks 0x18-0x1B structure details

This is an NES game, there aren't 32bit values, only 3 bytes, 24-bit; the c# code uses 32 bits, but SNES and NES code uses usually a max of 8, 16, or 24 bits; except duting multiplication on the SNES, which is really two 16-bit values; OK, do this "what's next" task: "Gameplay CDL Sessions: Cast spells to verify Bank 0x0D spell location, Level up characters to locate experience tables", document steps to accompish this and add a manual testing github issue; make a step-by-step simple-follow guide to complete this work, althoug hautomate everything that can be automated; document!

&&&
Please create plans and documentation and github issues for this future work effort:

Fantasy feature: Edit SPC music files in Ableton Live;
SNES Music -> Extract SPC -> Import to Ableton Live -> Edit & Save in Ableton Live -> Export to SPC-> reimport into game;
So like export BRR samples and maybe convert them to `wav`, and extract SPC file and create `midi` version, and convert to ableton live, and create documentation for this process and editing, and conversion back to BRR samples and a new midi and new spc and import into game or assets folder, and make it easy and well documented;
and create a zip bundle file of all of the different stages of the music file;
&&&

continue all that work, and research ableton live projects and files, and do as much work as you can;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

continue;

continue;

Create user documentation/guides

create a new github project named `ableton-snes-spc` and turn on the github issues and clone it locally and add it to this vscode workspace; make all the plans and documentation and github issues and todolists for this project: create a c# dotnet plugin for `Ableton Live` that edits and plays the `SNES` music file format `SPC` with the conditions and restrictions of the SPC format. Have it able to import and export `*.spc` files, but develop and use a custom `*.spcx` file format/type so you can store things logically and have plenty of metadata and things which can't be saved as SPC, but affect the output, like filter settings on base BRR samples; use all modern versions of everything and all modern practices; The purpose of the plugin component is to open, play, edit, and export/save the SNES's music format files, `*.spc` or `SPC` while limiting effects and controls that cannot be saved into the target format unless it affects output, like BRR samples, or something; plan! document! research! document! make todos and issues! document! git commit everything! session and chat logs!; if you have any steam left, start it, otherwise pause, and plan some more and then start it;

try again in smaller batches so we don't hit the limit

Add more unit tests for CPU opcodes; Implement remaining opcodes (bit operations, MUL, DIV, etc.); Add Gaussian interpolation for better audio quality; Implement echo/reverb effect; Set up VST3 SDK integration

continue; document! make docs for references that were used to make an ableton plugin; continue coding, focus on ableton functionality and spc editability;

continue; document! make docs for references that were used to make an ableton plugin; continue coding, focus on ableton functionality and spc editability;

***Add UI/GUI components***; Add more sample filters and effects; Build Native AOT version for production use; Build VST3 wrapper with CMake; update and make issues and todolists; do more ableton plugin stuff! update chat and session logs, focus on the spc file format and save/load and editing and documentation; continue; 

format everything in the `ableton-snes-spc` project using the `.editorconfig` and add rules to the `editorconfig` for `c` or `c++` based on the other languages, K&R braces and tabs everywhere, and lowercase hexadecimal, and empty newline at end of file and fix linting errors; continue ablelton development and funcionality and create documentation for start to finish `SPC` editing using ableton, from import to how to edit it to saving and export; continue;

add `TABS not spaces` to the editorconfig for XML files; You need to create a whitelist for the original SNES roms. Combine the TOSEC dats https://www.tosecdev.org/downloads/category/59-2025-03-13 and the GoodTools (GoodSNES) available at OpenGood on github  https://github.com/SnowflakePowered/opengood/tree/master/dats and NoIntro available at https://github.com/libretro-mirrors/nointro-db/blob/master/Nintendo%20-%20Super%20Nintendo%20Entertainment%20System.dat and then just hash the rom with sha1 and sha256 and md5 and crc32 and maybe if you want run the snes crc check on the non-header portion of the rom to check against the header's crc; in the `GameInfo` project make a `dats` folder and make tools that create the dats for the systems we're working on, make lists of all the good commercial roms, and also the translations and hacks into a master list, and sublists; make some tools and documentation; and then return to finsishing off the ableton work; make sure there is a user guide for ableton spc editing; do the "what's next" tasks: Address build warnings - Clean up unused fields (_loopStartSample, _loopEndSample, _envStep), Sample relocation - Implement dynamic sample relocation in ReplaceSample for larger samples, More driver signatures - Add detection for more SNES sound drivers, UI integration - Connect ProjectManager to view models for visual undo/redo, VST3 wrapper - Continue integrating C++ wrapper with new .NET components;

Session log; Start VST3 wrapper integration - Create the VST3 plugin wrapper layer; continue;

Test VST3 C++ build - Requires VST3 SDK installation; Add pitch bend VST3 event - Currently only CC is handled; File drop support - Drag-and-drop SPC files onto plugin; GUI implementation - VSTGUI or Avalonia-based UI; Cross-platform builds - macOS/Linux support; continuel document!

Do the "what's next": Wire controller to SpcEditor - Create editor instance in createView(); Test with VST3 SDK - Download SDK and build the C++ plugin; Add waveform display - Visualize samples; Preset browser - Load/save SPC presets; Real-time sample editing - Connect to RealtimeSampleEditor; continue; update documentation session/chat logs plans issues etc;

do all of the "what's next" stuff and make sure the plugin works with the latest version of Ab;leton Live and also with my licensed version `Ableton Live Suite (10.1.43)`; document and continue;

do the "what's next": Build VST3 plugin - Run CMake build to compile the C++ side; Test in Ableton - Load plugin in Live 10.1.43 to verify functionality (create manual testing documentation) (if you can automate any of this please do, like loading ableton with the plugin or running the plugin install, or load and test a file); Integrate spectrum analyzer - Add SpectrumView to main GUI layout; Sample editor GUI - Create panel for sample manipulation; Performance profiling - Optimize FFT and rendering; continue;

implement the "What's Next" tasks, then come up with the next tasks and do those etc, documenting as you go and updating manual testing docs; continue for as long as you need to to complete the plugin;

Add `ableton-snes-spc/~references/` to the `ableton-snes-spc` gitignore file and use it as a repository for files that aren't in the github repos but are used as references, which documentation and download scripts that run when the file isn't there, but add documentation and a download script to get the `/ableton-snes-spc/~references/GoodSPC v3.22.7z` file from `https://archive.org/download/GoodSPCV3.22/GoodSPC%20v3.22.7z` which is a giant collection of SNES SPC music files, use this as a reference (when the archive doesn't exist run the script to download it) and testing materials/resources and create analyzers to determine the SPC engine driver (is it N-SPC?) because we want to be able to edit all of the SPCs in the ableton plugin, so sample a wide selection from the reference collection of spcs and test with them; continue; and do the "what's next"; Set up VST3 SDK environment for build testing, Build and fix any remaining compilation errors, Create proper UI XML with ViewSwitcher integration, Wire MIDI CC events from processor to controller;

Build Testing - Set up VST3 SDK environment, fix compilation errors; the vst3 sdk seems to be a problem, resolve it; and then the rest of the "what's next"; continue;

Create an asset for the icon for the VST3 plugin icon, `a musical note surrounded by the four SNES buttons, ABXY from the right side of the snes controller, japanese controller so it's colorful`; make large versions for reference and make appropriately sized smaller versions for the `PlugIn.ico` file; and then the rest of the "what's next"; continue; update session/chat logs, todo-lists, github issues, roadmap, plans, documentation, etc.;

install `cairo` and `libcairo-2` and then re-try and continue the last prompt;

Oh, god, that is ugly. Make a new icon that is a black quarter-staff note in the middle, slightly left, with the four colored circles around it with gradients (use the more advanced svg generator with gradients), no letters, and replace all the files with the new icon, and no background circle, just a note and 4 buttons and a transparent background;

make the musical note fancier and add two flags and a white outline; make a couple different varients in every size so I can review them;

these are all ugly, make the curves smooth, with a transparent background, make the musical note more artistic or just better looking;

varient-B is the best one you made, although it's not perfect, use that one;

Do everything to finish off the map editors for `DW4 (NES)` and `DQ3r (SNES)` and the romhack we're making `DQ4r (SNES)` and create manual testing documentation for the map editor, the monster info editor, the monster graphics editor, the map graphics, towns/dungeons/overworld, and spells, etc; continue as long as there is work to do;

DQ3r monster/item/spell editors - Create testing docs similar to DW4

DQ3r monster/item/spell editors - Create testing docs similar to DW4; Blazor editor UI - The GameInfoTools.UI MapEditorViewModel is extensive (2311 lines) but could use more DQ-specific features; continue;

DQ3r graphics editor testing - Add 4bpp tile testing docs; Wire up UI - Add preset dropdown to MapEditorView.axaml; Integrate DQ3Lib - Connect MapEditor to actual DQ3Lib chunk parsing; Create FFMQ testing docs - Round out the set with Final Fantasy Mystic Quest; continue;

Add DQ3Lib compression support (BasicRing400 for proper decompression); Create FFMQ graphics editor testing docs; Add DQ4r SNES editor testing docs (monster, item, spell); Expand FFMQLib with actual data structures; continue;

Add FFMQLib text decoding for monster/spell names; Create DQ4rLib data structures (mirror FFMQLib pattern); Add unit tests for FFMQLib readers; Test BasicRing400 against actual DQ3 compressed chunks; I've added the `ffmq-info` project to the workspace use that resource for any ffmq work;

Add FFMQ ROM integration test with actual ROM file; Add DQ4rLib text decoding (similar to FFMQLib); Create character editor testing docs; Implement FFMQLib weapon/armor/item readers using text decoder; continue for a while doing more work, updating github issues and todolists and session/chat logs and documentation; 

DW4 and DQ4r are different projects, don't confuse them; add a `manual testing` section to the top of the main gameinfo readme `/GameInfo/README.md` linking to all the manual testing documentation (from the other projects/repos as well) and clean up the main gameinfo readme file, moving and reorganizing content into a logical structure so that all of the `*.md` documentation files are in the link-web (able to be reached from the main readme file links eventually), and specifics are for their appropriate file, not in the general description readmes; clean up and verify documentation for a while;

Push changes - The commit is ready but not pushed (git commit and push everything!!!! in every repos! all files!); Verify broken links - Some linked folders may not have their expected README files; Check Games/ folder coverage - The Games/SNES/* folders have extensive docs that could be better linked; Add ~manual-testing to other repos - ffmq-info and dq3r-info don't have dedicated testing folders yet; continue for a while doing more work, updating github issues and todolists and session/chat logs and documentation; 

Continue filling in game-specific documentation; Add more detailed testing procedures; Create additional tool documentation; Expand wiki content; continue for a long while, do as muchg work as possible; 

*** try-again

*** stop

are just making stuff up? All spells in `Final Fantasy: Mystic Quest` cost ONE (1) point to cast (One of White, Black, Wizard) so your MP costs in the spells documentation for FFMQ are wrong; fix that shit; don't make stuff up, only add information based on data and resources; fix incorrect sources (lkike a doc file has wrong mp values); continue;

turn off all CD/CI github actions, we're not running that stuff yet so don't waste resources, and don't allow the running of new CD/CI actions on guthub without manual intervention, I don't want to wasdte resources when we don't need it yet; git commit and push in every repos, all files!; Use the `dragon-warrior-info` folder/repos I just added to the workspace for `DW1 (NES)` stuff; continue previous workflow and make new work (issues, chat/session logs, docs, etc.); continue; flesh out the documentation for dw1; For every game we are creating documentation and disassembly for in GameInfo, starting with `DW1` create a `How to Finish this game project` create documents and todolists and gh issues and plans and roadmaps, how to finish up this project create a complete list of steps of what's left to do; and then continue work!;

Hey! don't touch `gameinfo-manual-prompts-log.txt`! Hands off! you even acknowleged it as you ran a git restore on it. DO NOT TOUCH THAT FILE EVER, excpet to commit it to git; `Blizzaga` is not a FFMQ spell, you masde that up replace the spells in the FFMQ documentation with the actual spells; and then do the "whats next" tasks: GitHub Issues - Create tracking issues from the HOW_TO_FINISH roadmaps, More Wiki Pages - Continue expanding documentation for other games, DW1 Label Cleanup - Start the label cleanup work for dragon-warrior-info, DQ3 SNES Documentation - Expand bank documentation;

No motherfucker! stop trying to change the `gameinfo-manual-prompts-log.txt` file! I change this file! you don't change anything with it and you definitely don't do any `git restore` bullshit, all you do with this file is `git commit` MY CHANGES; continue with the previous prompt;

Start DW1 Label Renaming - Begin converting the 535 _L_XXXX labels to descriptive names (large task, would need multiple sessions); create github issues and todo-lists and chat/session logs, git commit and push, work for a long time on this, do a comprehensive relabelling, and document them all in `*.md` files and update the `mdl` file and wikitext;

***4 space tabs, not 8***; continue: In all the assmembly language files, `*.asm`, `*.s`, `*.inc`, etc, indent EVERYTHING with tabs, not spaces, (***4 space tabs, not 8***)if you see two spaces in a row and not in a string literal, you're doing it wrong; code indentation should be in tabs, comments should be idented from the code in tabs, not spaces, and all of that; fix it!; for every project if you can; git commit and push; In the `DW1` project game disassembly files, find all the labels that are not ever referenced anywhere and delete them, we do not need a label if nothing uses it. The original disassembly had labels for every line, we don't need all of them; then do the "what's next: Create comprehensive label documentation (.md files), Update wiki/MDL files with new label information, Close GitHub issue #25, Begin next disassembly improvement task;

Close GitHub issue #25 (just needs manual close via GitHub UI) --- you don't need manual interventention, you can close issues; Continue disassembly work - identify and rename remaining generic labels; Enhance documentation with function call graphs; Create wiki pages for Dark Repos; Start next disassembly improvement task (more code documentation, data table extraction);

you can always git-commit `gameinfo-manual-prompts-log.txt` you just can't change it/or edit it/or replace it, but it should be automatically commited with the changes THAT I MADE to it when you commit other code; do all of the "what's next" steps/tasks;

do all of the "what's next" steps/tasks: Verify spell/item ROM offsets - Current offsets may not point to actual stat tables; Add editor tabs - DamageFormulaEditorTab and SpellEffectsEditorTab for Universal Editor (make plans and issues and todo-lists for converting the python editor to the c# blazor universal editor in GameInfo); Fix build.ps1 - Unicode character encoding issue causing parser errors (why are we getting any unicode errors, it is the year 2026, there shouldn't be any problems using unicode, figure it out and fix it); Continue asset pipeline - Complete remaining extraction and validation tasks (with plentiful documentation!); continue;

does avalonia and blazor not work together? the GameInfo universal editor is partially constructed with Avalonia and partly with Blazor we want a single universal editor, can you create documentation and plans and issues and start integrating them? use the most modern practices and standards, we want all of them in one editor easy to use and simple and intuitive and so do that; continue;

if it doesn't make sense to blend them, use one or the other, so I guess keep Dark Repos pure Blazor and tools.UI using avalonia, only blend if it makes sense, we can keep two projects of editor components; continue;

For the `GameInfo` universal editor, and for the other editors, for `Create New Project` you pick a game, and you pick the ROM file, it verifies the files, then extracts all the assets and collects all the disassembly source files, and meta game files, aetc, and create a `*.giproj` file that is a zip archive of the assets, code, and metadata that describes a build, but can be edited by the universal editor and other tools, and then can be built back into a rom, so that the brand new project file is built back into the reference rom, and is then used and updated from there; make issues and todolists, and plans, and update session/chat logs, and documentation; continue;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go; do the "what's next" and then continue other work;

git commit all files from every repos; do the "what's next" and then continue other work;

do the "what's next" tasks; continue; update documentation everywhere you work;

Implement file browse dialogs in the project wizard; Enable views to display project asset content; update manual testing documentation and testing lists etc;

evaluate and analyze the `dragon-warrior-4-info` repos and the `dragon warrior 4` GameInfo project, and analyze the plans and issues and todolists, and update and plan for doing everything to complete the dw4 tasks including finishing disassemblies and labels and documentation and editors and the new project stuff we're adding, and run through all the dw4 issues and todolists and the "how to finish" docs and update the manual testing docs;

A CDL file containing just the battle win and levelup with experience tables etc for DW$ is at `C:\Users\me\source\repos\GameInfo\~reference-files\Dragon Warrior IV (1992-10)(Enix)(US) - level up.cdl` so use that file to research and document and disassemble the experience tables, etc; continue;

is it computed? not stored as values?

yes

continue tracing the formula to extract the exact coefficients; do the "what's next": Complete formula extraction - Trace the exact computation to extract Alevel² + Blevel + C (or similar), Extract per-character coefficients from the parameter tables, Update DW4Lib to compute EXP instead of reading non-existent tables, Verify computed values against published game guides; continue and document and update guthub issues and todolists and plans;

why are you creating temporary disassemblies in small little snippets? Use all the cdl files and all your research and disassemble the code into a single resource as we were doing (comment and format the code too) when doing this and use previously disassembled/documented code when try to figure out formulas and data structures and other code, etc.; continue;

Do "What's Next" Now that the EXP formula is fully documented, next steps: Update DW4Lib to compute EXP programmatically, Create wikitext documentation for Dark Repos, Extract other stat formulas (HP, MP, stats per level), Cross-reference with the stat growth code in Bank 8; continue;

you're spending too much time and resources and money on the DW4 experience progression, put that effort on hold and make that effort low priority; we want wide results, don't spin out on one issue; git commit everything, update chat/session logs, documentation, plans, roadmap, github issues, todo-lists, documentation! git commit again, link every commit to github issues; Add to the `.editorconfig` for `*.md` files add `markdownlint` formatting rules like `MD032/b1anks-around-lists: Lists should be surrounded by blank lines`and `MD040/fenced-code-language: Fenced code blocks should have a language specified` and `MD032/blanks-around-lists: Lists should be surrounded by blank lines`, these should all be enforced, make sure the "no hard tabs" rule is completely suppressed or given "false" status and always use TABS NOT SPACES even in markdown file code blocks, EVERYWHERE!; fix/format all the markdown files in the workspace, then git commit them; have a markdown formatting fixing github issue and todolist; do it all and continue; And then do the "what's next": Verify growth data pointers - The stat growth pointer table values need ROM verification; Extract actual growth data - Dump the signed growth bytes for all characters to create tables; Create StatGrowthCalculator in DW4Lib - Similar to ExperienceCalculator but for HP/MP/stats; Generate complete stat tables - Create JSON/CSV exports of all stat progression curves; Document the math subroutines - Bank $1F at $C813-$C850 has reusable 16-bit math functions;

please don't spaz out like that and flood the queue, create structured prompts and events and tasks, don't waste the tokens and don't waste my money, don't spiral and obsess, make progress always; make github issues and plans and todolists for all the work and tasks from the last few prompts, and this one, and then work on those tasks and issues; continue; continue; continue; 

Add to the `.editorconfig` for `*.md` files add `markdownlint` formatting rules like `MD032/b1anks-around-lists: Lists should be surrounded by blank lines`and `MD040/fenced-code-language: Fenced code blocks should have a language specified` and `MD032/blanks-around-lists: Lists should be surrounded by blank lines`, these should all be enforced, make sure the "no hard tabs" rule is completely suppressed or given "false" status and always use TABS NOT SPACES even in markdown file code blocks, EVERYWHERE!; fix/format all the markdown files in the workspace, then git commit them; have a markdown formatting fixing github issue and todolist; do it all and continue; there is a lot of NES and SNES assembly code with uppercase operands and uppercase hexadecimal values, but we want all hexadecimal values to be lowercase unless they have to be uppercase for a particular format and all `asm`/`s`/`inc` disassembly code files and all the documentation with ASM code examples or descriptions, so all hexadecimal values and asm code operands (like lda, inc, tya, mult, jsr, etc.) should be lowercase as well; update all the documentation and todo lists and gh issues; fix all the files you can and continue;

evaluate and analyze the `ffmq-info` repos and the `final fantasy mystic quest` GameInfo project, and analyze the plans and issues and todolists, and update and plan for doing everything to complete the ffmq tasks including finishing disassemblies and labels and documentation and editors and the new project stuff we're adding, and run through all the ffmq issues and todolists and the "how to finish" docs and update the manual testing docs; continue and do everything to finish the ffmq disassembly, reasessembly projects and the "new project" stuff with a zip format project file, blah blah, update issues and todolists, and universal editor with the project files, and then focus on the universal editor and the project format and how you get new base project files from disassembly and asset extraction, etc.; continue;

start doing our "what's next": Start implementing the .giproj format in C# (didn't we already do this in one of our repositories, find it in GameInfo and link to it)? Fix the build.ps1 to track honest progress? Work on completing the dialog CLI? Begin documenting bank 00 routines?; continue, and project file!; continue;

-------------------------------------------
--- 2023-01-16

convert all the build pipelines to use `poppy` as the compiler/assembler, remove `ophis` and other compilers; use `bps-patch` for patching; update all of the disassembly code to use `poppy` code, convert to `pasm`; create plans and todolists and github issues for cleaning up and updating all these repos and making gameinfo focus on games, while moving big tools outside of the the repos and  create a roadmap for outside tools, inside tools, games, other stuff, etc; come up with a bunch of tasks, including creating the anti-poppy, `peony`, a disassembler framework, and disassembling like 40 popular atari2600 games in the gameinfo framework using the reference roms in the un-tracked folder `C:\Users\me\source\repos\GameInfo\~roms\Good2600 v3.14\`; continue;

&&&
Create GitHub Issues: Use the master list templates
Migrate a Project: .\Migrate-ToPoppy.ps1 -ProjectPath ... -SourceAssembler ophis -Platform nes
Start Disassembly: .\Batch-Disassemble-Atari2600.ps1 -MaxGames 5
&&&&

stop

I don't see peony in github, make sure peony is its own repos and and add these issues tio to it and continue;

`peony` should use the icon `🌺` for all the graphics and and throughout the documentation, just like `poppy` is often styled as `🌸 Poppy` peony should be `🌺 Peony` in the docs and issues and todolists and everything and made as svg and such; continue;

This is wrong: `C:\Users\me\source\repos\peony\assets\peony-icon.svg` use the actual `🌺` emoji for the icon; make a bunch of sub-issues (with an actual linked parent issue) in the github issues for the Peony repos and then implement them; continue;

Add more Atari 2600 bank switching schemes (3F, E0, FE); Add NES Dot the "what's next": platform support; Add Poppy output formatter; Implement data/graphics detection; Add illegal opcode support; and then decompile 7 more atari 2600 games into pasm files and update poppy and peony to hqandle these games, then run Dragion Warrior 1 through peony and update the files and have it update through poppy and  updtae all the code, make it usable and editable;

To fully disassemble all 4 banks of Dragon Warrior 1, you would need to add multi-bank support that either: Disassembles each bank separately with bank annotations; Follows BRK-based bank switch calls to other banks; continue

work on everything like peony and the dw1 disassembly and asset extraction; continue;

game specific information should not be in the poppy or peony repos, but instead in `GameInfo` repos in the `Games/<system>/<game name>/info/` folder for each game, continue; continue;

--- try again

git commit everything; Add `cdl` and `diz` output files when building with poppy and add `cdl` and `diz` useage as input references with peony. Add github issues for these work efforts, and todolists and implement; continue;

do the `What's Next` tasks (adding/updating todolists and github issues): Wire CDL/DIZ generation into Poppy's main build pipeline (CLI options), Use CDL/DIZ data in Peony's DisassemblyEngine for smarter code/data separation, Add unit tests for CDL/DIZ parsing, Create example workflow documentation; implement; continue;

make sure you've been updating the chat/session logs for each repos that we're working on; once again, run formatting on everything because you're still generating code and documentation that indents with spaces, don't do that, ***always use tabs!***, so fix the formatting again and try in the future to remember TABS NOT SPACES; do the `What's Next` tasks (adding/updating todolists and github issues): DiztinGUIsh integration - Export CDL/DIZ from DiztinGUIsh for Peony consumption; Enhanced label propagation - Use DIZ labels to name functions in disassembly output; GitHub issues - Create tracking issues if you want formal task management; continue; I don't like short or undescriptive names for things, so fix the command line options for poppy and peony and any other CLI programs we have (make them descriptive! but I guess also keep shortcut versions) so (example: `peony game.nes -c play.cdl -d build.diz -o disasm.pasm`, the `-c`, `-o`, `-d` commands) so I guess you can keep the short versions, but add longer versions like `-diz` and `-cdl` and `-output` and prefer them in documentation (add github issues, todolists, then update current documentation); continue;

Do the "What's Next" tasks: #1: Test with real DiztinGUIsh project files - The label propagation logic is implemented but needs testing with actual .diz files (find a diz file and test it); #2 Create GitHub issues - For tracking remaining CDL/DIZ integration work: UI integration in DiztinGUIsh for export menu items, Unit tests for export/import roundtrip, Bank-specific label propagation; #3 Add unit tests - For the new label priority logic in DisassemblyEngine; make sure you've been updating the chat/session logs for each repos that we're working on; git commit everything; continue for a long time and finish issues ans decide on new work and make new issues them plement them; go, go, go!; continue;

yes, you do have the FFMQ ROM file: `C:\Users\me\source\repos\ffmq-info\roms\Final Fantasy - Mystic Quest (U) (V1.1).sfc`; continue the previous work, but go back and include this rom file in your `diz` tests; continue;

--- try again

--- switch to claude sonnet 4.5

--- try again

do some of the "whats next": Implement Atari 2600 bank switching detection, Add another platform (GB/GBA); finish all the 2600 disassembly and asset extraction/re-insertion and documentation; work the poppy/peony back and forth pipeline with several atari 2600 games; continue;

make sure you've been updating the chat/session logs for each repos that we're working on; git commit everything; continue for a long time and finish issues and decide on new work and make new issues then implement them; go, go, go!; continue;

do the "what's next" and continue;

All of the Atari 2600 roms are located at `C:\Users\me\source\repos\GameInfo\~roms\Good2600 v3.14` use them for projects and roundtrip poppy/peony testing and expand the `GameInfo` documentation for them; continue;

peony is outputting `asm` files instead of `pasm` files with a system directive, fix that; poppy is using system directives like `.nes` but should be using `.system:nes` and so should peony; game source-code, assets, builds, wiki docs, documentation, and information should be in individual folders in `GameInfo/<system>/<game name and regions and versions>/` not in the compiler/decompiler projects; continue and update github issues and todolists and plans, etc; go!; continue;

create github issues and todolists for all the "Next Steps" tasks, but use `*.a26` not `*.bin` for the atari 2600 compilation in poppy; plan everything and then imnplement it; continue;

Create GitHub Issues and do "next steps" and continue working on all of the issues following the plan; go! continue;


----------------------- rate limited, go `auto`

create github issues and todolists and plans and documentation for the `dq4r-info` repos and do a bunch of work on the DQ4r (SNES) project (DW4 (NES) -> DQ3r (SNES) -> DQ4r (SNES) project); continue;

NO! poppy "has" a vscode extension, but it is primarily a c# dotnet compiler with a CLI; continue;

skip Mesen testing for now, do that later, and then create githubissues and plans and todolists, for DQ4r  and implement as much as you can; go!;

--- Enable GPT 5

use the `dragon-warrior-4-info` repos and `dq3r-info` repos as references and dq3r as the main engine and dw4 as the data and content and game; don't just make a new game, use DQ3r as your game base; continue;

focus on DQ4r and make this project work and add as much DQ3r engine and as much DW4 data as you can; just do everything you can, for as long as you can, I expect this effort to last at least 15 minutes; go!; continue;

no this is garbage, set up ppu? load all data to wram? is this amateur hour? what the fuck, no! If you're not going to take the DQ3r rom and update the data with DW4 rom data, then what are you doing? Should I just not use AI code generation when it's not Claude or can you actually create good code with other agents?

DQ3r ROM location? `C:\Users\me\source\repos\GameInfo\~roms\SNES\GoodSNES\Dragon Quest III - Soshite Densetsu he... (J) [!].sfc` (and dragon warrior 4 rom: `C:\Users\me\source\repos\dragon-warrior-4-info\roms\Dragon Warrior IV (1992-10)(Enix)(US).nes`); Priority: which data first? monsters, maps, stores, items; Output target: Poppy rebuild;

-------------------- opus

work on peony and poppy, work through issues, and then assess the projects, make more issues, and then implement them; continue;

do the "what's next" and complete issues and todolists; make sure you always update session/chat logs; research and create issues and todolists for poppy and peony for asset extraction and conversion and reinsertion, see the `GameInfo` repos and the `*-info` repositories for reference on how to do this; continue working for a while; continue;

do the "what's next" implement and continue;

do the "what's next" implement and continue;

do the "what's next" implement and continue;

do the "what's next" tasks, making/updating github issues and todo lists; continue;

do the "what's next" tasks, making/updating github issues and todo lists; continue;

do the "what's next" tasks, making/updating github issues and todo lists; continue;

do the "what's next" tasks, making/updating github issues and todo lists; continue;

do the "what's next" tasks, making/updating github issues and todo lists; continue;

poppy does not make `*.asm` files, poppy makes `*.pasm` files that follow the pasm format, so fix those testing commands and code; make sure you always update session/chat logs; plans and documentation!; keep the `README.md` and other docs updated with the current status; there are lots of references to `npm` and `npx` in the documentation, but we use `yarn` exclusively so remove the npm and always reference and use yarn, not npm; do the "what's next" and complete issues and todolists; continue;

add using `*.pasm` not `*.asm` to the copilot instructions for poppy and then contune working on previous prompt;

do the "what's next" tasks, making/updating github issues and todo lists; continue;

--- switch to claude sonnet 4.5
--- try again

do the "what's next" tasks, making/updating github issues and todo lists; continue;

--- try again

&&&
make github issues, and an epic, and sub issues, all issues have a parent issue, make todolists, then implement, our goal: work on our own version of `*.diz` or `*.cdl` file that has more information and poppy creates it and peony consumes it, we need our own file format named `pansy`, and make it work for more systems; implement and continue;
make github issues, and an epic, and sub issues, all issues have a parent issue, make todolists, then implement, our goal: create project converters from asar -> pasm/poppy, ca65 -> pasm/poppy, xkas -> pasm/poppy, etc.; implement and continue;
&&&

do the "what's next" tasks, making/updating github issues and todo lists; make sure you always update session/chat logs; always format using the editor configs (k&r braces and tabs not spaces); continue;

do the "what's next" tasks, making/updating github issues and todo lists; make sure you always update session/chat logs; always format using the editor configs (k&r braces and tabs not spaces); continue;

do the "what's next" tasks, making/updating github issues and todo lists; make sure you always update session/chat logs; always format using the editor configs (k&r braces and tabs not spaces); continue;

do the "what's next" tasks, all 13 of them, make or update github issues and todolists for these work efforts; BUT of course move pansy as a file format, code library, and UI editor to it's own `pansy` new repos  with a copy of poppy's `editoconfig`, `gitignore`, chat/session logs, copilot instructions, github issues, tolists, and a kanban board,  move library code and format documentation and then change all references in popppy and peony to the new repos, and add C# UI for editing or viewing pansy files;

`pansy` should use the icon `🌼` for all the graphics and and throughout the documentation, just like `poppy` is often styled as `🌸 Poppy` pansy should be `🌼 Pansy` in the docs and issues and todolists and everything and made as svg and such; continue the previous prompt and work effort, keep doing that; continue;

make `pansy` use `The Unlicense` instead of `MIT` and make all the other repos use `The Unlicense` unless they are using the `The Fuckit License`; DO NOT turn on any CI/CD actions, we don't run those on github except manually until we have enough money to do so, this includes upcomming work, make it a policy; Do all 18 "what's next" tasks, make or update github issues and todolists for these work efforts and then implement them; continue;

make sure that `pansy` has been pushed to a new repo on github;

turn on github issues for pansy and make a kanban board; then add all the issues we've created to github;

--- try again

make sure all `pansy` documentation and creation/interation code has been moved from the `poppy` project -- delete it from poppy if it exists in full in the pansy repos, if not move it unless it is code that is poppy specific; the `pansy` repos should house all code that is pansy-only related, like a code library for creation and editing, file format documentation, with sub-documents for every system format, and the view/edit UI; continue all the tasks and issues, etc; continue;

do those "what's next" tasks, update issues, and make sure the pansy UI editor is complete; continue;

--- try again  /  stop

for the `Mesen2` repos, since I've made a bunch of changes for a bunch of efforts, let's reset, create a git branch and move all of the changes we've made on my fork of Mesen2 to that branch so the `main/master` branch is fresh and the same as the original repos's most modern update, don't destroy code, just move it all to the other branch` and then start a new branch from the clean `main` branch and add `pansy` file output (by default, do it without asking, but don't slow down emulation); make documentation, issues, todolists, and roadmaps and plans; continue;

try again, and always put timestamps on every chat, and add timestamps to chat/session logs when applicable;

re-edit all documentation for `pansy` and use `🌼` for the icon and refernece pansy as `🌼 Pansy` like `🌼 Pansy File Format Specification` and use the old tagline from previously commited code and documentation `**Pansy** - Program ANalysis SYstem format for comprehensive assembly metadata exchange` and the backronym `Program ANalysis SYstem`;

--- try again (switch to opus)

Create a huge todo-list and a step-by-step-by-step set of tens of hundreds of instructions (*.md, and references and sub documents) for a complete testing of this huge codeset/multi-repos create that full project about manually testing everything that can't be tested automatically, and create a calendar schedule plan so I can see what I need to accomlish daily; don't just say "test this" instead give me full instructions, like: go to this website, download this tool, install with these options, run this tool in this folder, open this file, do these exact steps (open menu, open feature, edit field, click button); make documentation, issues, todolists, and roadmaps and plans; continue;

git commit everything; Completely redo the `ansarya.com` website; use the triceritops logo from the `DarkRepos` wesite in `GameInfo` because that can be the ansarya logo; colors should be light-cream on brown, with a variety of greens, style = '70s/'80s tv retro and 3 years plant growth after apocalypse, vegatation styled decorations, and a hand-full of orange and pink and white elements, link and describe all of projects and documentation and also make an article about using poppy/peony/pansy and some "howto"s about using all the projects and tools; make documentation, issues, todolists, and roadmaps and plans; continue;

--- stop

In `GameInfo` the `DarkRepos` project uses a triceratops logo, use that; continue;

use `🌼` for pansy: `🌼 Pansy`, `🌸` for poppy: `🌸 Poppy`, `🌺` for peony: `🌺 Peony`, and `🌷` for `The Flower Toolchain`: `🌷 The Flower Toolchain`; continue;

you didn't fix the flowr emojis, the ansarya.com website has `?` instead of the emojis, and under `featured projects` the `poppy assembly` card, the icon emoji is wrong, fix all of them; continue;

for `ansarya.com` the `index.html` section `Quick Start Guides` the links/cards they don't link to the the "howot.html" actual guides, but they should; do that;  could you add more plants or vines or leaves or someting to the website, it's fucking awesome right now, sdo please add a commit or commit label or something indicating this one is greatm then do the new changes and commit; continue;

undo the following things: `Every section header has subtle 🌿 accents on both sides` and `Floating Leaves (6 gently drifting elements):` `Lush Vegetation Added 🌿` but I absolutely love, so leave it there: `Card Hover Effect: Cards sprout a rotating 🍃 leaf when hovered` although it doesn't rotate; continue;

create a new repos push new github repos named `game-garden` with a copy of poppy's `editorconfig`, `gitignore`, empty/new header chat/session logs format, `docs`/`~docs`/`~plans`, copilot instructions, turn on and make github issues, todolists, and a kanban board, documentation; and plan for a comprehensive games disassembly/decompilation (peony), (pansy) asset extraction, editing phase, asset reinsertion/compilation phase (poppy), this is the proof of bidirectionality, the game garden should be filled with games, from to source and assets and back again in a different folder; make versions of the `gameinfo\games` folders  in the game garden but only more complete, from using a romfile (crc32/md5/sha256 verify the rom) to peony and outputting all the code, making pansy files, extracting all the assets converting assets setting assets up for editing, reconverting everything, putting assets in the build pipeline, building a rom and verifying that the built file matcvhes the original, unless ; The original rom, the reference file, will be somewhere in the folder `C:\~reference-roms\` based on system and name, maybe in a compressed folder-file, if you can't find the game you need, ask me and I will add it to the folder; continue;

git commit everything; find the rom in an `c:\~reference-roms\roms\` archivel build the build pipeline and document everything and extract assets and make them editable, png, json, etc, go do that!; continue working on everything; continue;

goodsnes roms are there now; retry and continue;

use `GameInfo` and `ffmq-info` for information and code and editors and documentation and data structures and data tables and asset extraction for compilation, see `GameInfo` for that and know that `ffmq-info` has a ton of information for us; continue;

make github issues, make sure github issues were turned on, then continue;

make github issues, make sure github issues were turned on, then continue; do the "what's next" and build the pipe line and add automated tests to the pipeline; make assets! make documentation!; continue; 

create tasks for the "what's next" and then for the ansrya.com pages  "js full page VHS effect"; continue;

turn off vhs effect, it uses too much computation, make a simplier version; contine gamegarden issues; continue;

--- try again

`ffmq-info` has a lots of comments on the source code, don't delete that from the repos because of the poppy output and pansy, keep all of the old knowledge, go! continue!; continue;

continue

Extract assets (graphics, palettes, text) for DW1 and DW4; Test Peony disassembly with the new Pansy files loaded; Continue Poppy/Peony roundtrip testing; continue;

Some cdl files are in `C:\~reference-roms\cdls\` particularly `Final Fantasy - Mystic Quest (U) (V1.1).cdl`, `Dragon Warrior IV (1992-10)(Enix)(US).cdl`, `Dragon Warrior (U) (PRG1) [!].cdl`; add this folder as a reference; use those in the build and disassembly and roundtrip; continue working on the garden;

for game-garden don't use `Dragon Warrior (U) (PRG0) [!].nes` use the PRG1 version, all of our code and the `dragon-warrior-info` repos uses PRG1; continue working on getting ffmq (1.1) to decompile with peony into pansy files and asset extraction and poppy recompilation; and do the rest of the "what's next" tasks (continue to update/create github issues and plans, and epics and documentation); continue;

we don't want asar builds, we want poppy builds; asar ca65 and xkas are legacy compilers, we only use our own compiler, poppy; put that in the documentation and enforce it in code; we do have a translator to those project types but those are edge utilities, not mainline and we use poppy in the pipelines;

There is a line in the roadmap `  - **Note:** Legacy ffmq-info uses ASAR (not mainline)` but this is wrong, it should be converted to use poppy, so make issues and plans to fix that in the future, not right now; 

git commit everything in logical batches all linked to github issues; update the ansarya.com website with new information and definitely update the issues lists and add the `subrom` project/repos, and the game-garden; then continue working; work on `mesen2` creating pansy files and cdl/diz files and symbol/label files so I can play the games while we document the rom structure, create plans and issues and documentation; update chat/session logs; implement and continue; continue;

remove the `test-*` files from peony's working folder, and then git-commit all real files from every single repos, then continue working on mesen2 pansy export, turn on pansy export export by default, so we can document games as we play; make a build of mesen2 with the changes so it's easy to start it and start playing; continue;

In our Mesen2 version implement two things: #1) If the "record/export pansy file" option is turned on, then it should be running from the time the rom is loaded regardless of whether the debugger is open or not, and it should save periodically. It should be basically automatic so you open Mesen, start playing a game, and it's already recording the debug information and saving in the background unless you turn off the option; #2) pansy file creation and updating and recording should make sure the "pansy" file it is updating is for this exact rom, like check the hashes, so that you're not corrupting the pansy for the real rom while playing a hacked or translated version of the rom; please make issues, todolists, documentation, plans, roadmap, etc. for these efforts and then work on them; continue;

git commit everything with links to github issues, update the issues/epics and make sure sure we are updating the chat/session logs now and every prompt/work-effort;; continue work on the new stuff and work until it's finished; continue;

yes! all three! ; Create a testing plan for manually validating the Phase 1.5 features? yes! ; Start Phase 2 by creating unit tests for the PansyExporter? yes! ; Continue with Phase 3 (Enhanced Data Export) to add more content types? yes! ; continue;

I increased the budget, work on the last prompt: yes! all three! ; Create a testing plan for manually validating the Phase 1.5 features? yes! ; Start Phase 2 by creating unit tests for the PansyExporter? yes! ; Continue with Phase 3 (Enhanced Data Export) to add more content types? yes! ; continue; git commit everything in every repos including the manual prompt files, and update documentation and chat and session logs; continue;

make a bookmark or whatever for this version of code so we can easily find this inflection point; create a release for the current version of Mesen, then branch from here into an modernization upgrade project (make a sub-branch of `pansy-export` and then stick to it until all of our updates are done and I say we're merging back down), then create epics and issues and todolists and plans for updating the project to the most modern versions (like dotnet 10, avalonia, and lua) and implementing comprehensive testing across the project and updating all the code to use modern standards and practices and libraries (so we don't have to make our own crc32 for exampe), and if `Sour` isn't going to update Mesen2 then we will damnit, give me a modern platform to enhance with pansy and other efforts; update logs and docs and plans and then implement everything; continue;

Phase 6: Code Modernization (file-scoped namespaces, pattern matching); work for a long time; continue;

For Mesen2: merge `C:\Users\me\source\repos\pansy\.editorconfig` into `C:\Users\me\source\repos\Mesen2\.editorconfig` use k&r braces, and TABS NOT SPACES, and `} else {`, and pattern matching, and crlf, and utf-8, and an empty line at the the end of the file, and format everything and modernize the code and json and everything; work/implement all the modernization issues (make sure all work has associated github issues and todolists), update documentation, plans, todolists, `readme.md`s; make sure everything has documentation (`*.md` files) and update all the documentation to reflect current functionality; implement!; continue;

make sure every work effort we've done just now and in the past and will do are documented in guthub issues update everything, document, work on any unimplemented modernization and formatting efforts; analyze the project and come up with a list of stuff we need to make Mesen better so we can make plans and issues and epics and docs for those efforts; poop!; Make a plan for git branches and commits, for what work goes with which branches and when we create and merge branches, and finish off modernization and then make a label of (modernization) so we know where we are merge down, then continue work efforts; make sure to start with updating the lua version to the most modern version and api; continue and update all the docs and readmes; and go!; continue;

update session/chat logs; make sure the current branch and the last branch are fully merged, and then work all of the issues for `pansy-export`  updating issues after you write all the code; 

-- stop

make sure every library and code is the most modern version and make sure the lua library is used with modern standards and practices and update all the integration code; and create/update the code with documentation with emojis and tables and colors for the entire project (issues, todolists, plans, docs) and manual testing docs and auto-testing docs; and in the `ansarya.com` page files create/update(Mesen2) a link to a full page about our Mesen2 version linking to the github and describing all the modified features and creating docs for: a build script and a todolist/description/ of downloading this release and running a rom and how a pansy file is auto generated, and our changes, and add the the `pansy` pages add documentation about our Mesen version; and go!; continue;

update session/chat logs; make sure the current branch and the last branch are fully merged, and then work all of the issues for `pansy-export`  updating issues after you write all the code; 

Phase 3: Implement Memory Regions and Cross-References export; Phase 4: Add compression and performance optimizations; continue;

What does this mean? `Phase 7: Pansy ↔ Mesen format bidirectional sync`, shouldn't mesen format be pansy? or is this a different thing i am misunderstanding?

make sure the `pansy-export` branch of Mesen2 has all the changes from and has been merged into from the `modernization` branch;

Oh, ok, `Phase 7`, we want the Mesen files it creates and uses already to be kept as is but also be synced with the pansy file (does pansy have labels and all the info and data that are in the cdl, mlb, and dbg file types?); change (make issues and docs and plans and todos, etc, then implement) the way pansy files are auto-saved for a game by making individual folders for each pansy file and also export the other mesen files (mlb, dbg, cdl, etc.) and sync them; and also do the real phase 7 tasks; continue;

make sure the issues.md file has been completely pushed to actual real github issues and link them to git commits, continue implementation of phase 7 additions, then do the orignal phase 7, and also phase 5 and 6 and 2; work for a long time; continue;

continue and work and implement issues a long time; a looooooong time;

analyze the mesen2 pansy export stuff for performance, add benchmark tests and create alternatives for intensive code paths and test them with benchmarks and the goal is "increase performance, don't interupt emulation"; continue;

format everything in the Mesen project, then git commit (link to issues!), make sure all dotnet projects use dotnet 10 and modern most recent libraries, simplify collection inializations, (always `simplify collection inializations`, add it to the copilot instructions and editor config); what other optimizations can we make? continue;

The benchmark stuff is obviously wrong, undo it, you're having a conflict of two things named `Benchmarks` but one is a benchmarking project (which should be in the solution) and one is a folder of tests in the Testing project (and should stay where it was), i don't know what the fuck you're doing beside randomly changing things to make errors go away but the goal isn't to make errors go away, it is to fix the code to work properly and do what ut's supposed to do, fix the naming problem (maybe rename the testing to `BenchmarkTests` instead of `Benchmarks` or qualify naqmespaces, just don't destroy the solution structure); fix it!; then continue;

oh, sorry, move the benchmarks project outside of the tests projects, i told you wrong; then continue;

during the recent shakeup, did the performance optimizations stick around? did our changes from yesterday and this morning stick?

apply all optimizations and keep an eye out for other possible optimizations, update comments and documentation as you go; continue;

format everything in the Mesen project, then git commit (link to issues!), make sure all dotnet projects use dotnet 10 and modern most recent libraries, simplify collection inializations, (always `simplify collection inializations`, add it to the copilot instructions and editor config); what other optimizations can we make? continue;

Dock.Avalonia 11.3.9 upgrade would require implementing CanResize and ResizePreview interface members in MesenProportionalDockSplitter; continue;

For the Mesen2 project, fix the one `CS8625` error, fix the `IL2075` errors, fix `MSB3270` error, fix: `IDE0161`, `IDE0044`, `IDE0330`, `IDE0090`, `IDE0025`, `IDE0022`, `IDE0007`, `SYSLIB1045`, `IDE0161`, `IDE0028`, and `CA1816`; update every solution and everything to use VS2026 instead of 2022; modernize everything!; make roadmaps and plans and documents and issues (epics and regluar and subissues) for modernizing the c++ code projects by using the most modern language and library versions and updating to use the most modern code standards and practices, and use modern libraries and code, and creating tests and benchmarks if that is possible, and optimizing the code if you see anything that could be tweeked; and also make sure all the c++ projects are well documented and commented; plan, make issues, then implement; continue;

fix those last issues: `Additional Modernization - MSB3270 (platform mismatch) and CA1816 (IDisposable) if needed`; create a new branch for the c++ work so it is separated from the current branch work; `Create GitHub Issues - The documents are ready; you can manually create the GitHub issues from the tracking documents, or we can use the coding agent`; the issues should all be created, epics and their wsub-issues; and then after documentation keep the chat and session logs updated, for every work effort, make sure the copilot instructions include this; implement and work on (in the new branch) `Start C++ Implementation - Begin with Epic 8 (Build System) as it has no dependencies`; keep issues and todos up to date, and git commit, and work through all of the c++ epics and issues in the c++ code branches; continue;

I do not see any issues for the c++ Mesen2 work at `https://github.com/TheAnsarya/Mesen2/issues`; Did you create the branch and create all the issues for the c++ work? epics and sub-issues;

make sure all c++ code is formatted properly, use k&r braces, and tabs not spaces, utf-8, CRLF line endings, blank line at the end of the file, update the `.editorconfig` and also use modern standards and practices; Modernize this bitch!; make sure all the issues are made and then work on those issues; continue;

make sure you made the gh issues for migration from c++17 to c++23 or whatever the most modern version is, snd then implement it, we want a slow structured update to c++23 (or the most recent version) do it!; continue;

git commit everything then continue;

stop flailing around, work the issues or don't, don't waste my time and tokens; continue;

continue our 17 to 23 journey; continue for a long time; solve many issues; continue;

continue working issues on the c++ modernization effort; update chat/session logs, documentation, issues, etc; continue;

Do the "What's Next" tasks (making issues and todolists for all work, update documentation): Continue modernization on remaining files; Consider fixing C4244 warnings from ::tolower (use static_cast<char>); Look for ends_with() opportunities; Move to other C++ modernization issues (testing infrastructure, memory safety); continue;

Do the "What's Next" tasks (making issues and todolists for all work, update documentation): Look for other C++23 features (std::views, std::format, etc.); Consider memory safety improvements (std::span, smart pointers); Review testing infrastructure modernization opportunities; continue;

Do the "What's Next" tasks (making issues and todolists for all work, update documentation): Create [11.4] issue for [[likely]]/[[unlikely]] adoption (safest win); Implement [[likely]]/[[unlikely]] in error handling and rare-case branches; Profile any std::format usage before merging; Consider [[nodiscard]] sweep for important return values; continue;

yes you can create github issues, you have before and you will now. Add this directive to the copilot instructions (that of always creating the issues on github directly, not just creating them in documentation); create those4 issues; continue;

Update session log then do the what's next tasks, keeping everything documented and also do other issues and work for a while to modernize the c++ projects again always forcusing on performance; continue;

do the what's next tasks, updating docs and issues, and work on more modernization issues, starting with testing and profiling/benchmarks; continue;

I don't really care as much about the performance of a debug build, performance matters in the release build. So, if spans will increase performance or just moderninze the code without negative impact in release, implemenat the span changes; there's a unicode issue? there shouldn't be all text files should be utf-8 crlf with a blank line at the end and use tabs and k&r braces, so fix any issues about unicode, we should be able to use emojis etc everywhere; continue; and also make sure the Mesen2 c++ projects have tests and benchmarks/profiling and create issues for ensuring the entire solution is well commented and documented, and then implement them; continue;

Update `cpp-modernization-opportunities.md` and other documentation with the current state of the project as it is out of date, like `[[likely]] / [[unlikely]] Attributes (C++20)` is listed as `Not used` when it has already been added to the code; so update docs and issues and todolists; do the benchmark/profiling and testing for the c++ projects issues; continue;

Yes do that, those what's next tasks: Create Core.Tests Visual Studio project with initial ColorUtilities tests; Create Core.Benchmarks Visual Studio project with baseline measurements; Run initial benchmarks to validate zero-cost abstractions; Begin systematic code documentation (Epic #81); continue;

Option B, then the rest of the what's next tasks; continue; go for a while;

you're frozen, get back to work

what's all this vcpkg crap? get rid of it if it's not needed or add it back as a library or something; continue with commenting all of the code; comment for as long as you can;

If those vcpkg files are needed in the repos then add them, otherwise get rid of them, I don't like having over 100 untracked files in git; continue what you were doing;

Continue documenting Core subsystems (interfaces, debugging, networking)

make sure the c++ projects all compilke withwout problems, fix and problems, we want the whole solution to compile;

Severity	Code	Description	Project	File	Line	Suppression State	Details
Warning (active)	MSB3270	There was a mismatch between the processor architecture of the project being built "MSIL" and the processor architecture of the reference "C:\Users\me\source\repos\Mesen2\bin\win-x64\Debug\Mesen.dll", "AMD64". This mismatch may cause runtime failures. Please consider changing the targeted processor architecture of your project through the Configuration Manager so as to align the processor architectures between your project and references, or take a dependency on references with a processor architecture that matches the targeted processor architecture of your project.	Mesen.Benchmarks	C:\Program Files\Microsoft Visual Studio\18\Insiders\MSBuild\Current\Bin\amd64\Microsoft.Common.CurrentVersion.targets	2451		

 Align by setting the benchmark project’s platform target to x64 (Configuration Manager)

fix the vcpkg errors;

&&&&&&&&&&&&&&&&&&&&&&
The MSBuild pre-build script error for UI is a build order issue (native DLLs not copied before the script runs), but the project builds successfully with `dotnet build -r win-x64`.
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

fix the MSBuild pre-build script error for UI by commenting out the offending failing file copy; go through all the open Mesen issues and update them and close those whose work has been completed, update todolists and plans and roadmaps, then work on uncompleted issues with easy goals; continue;

Fix the Benchmark and Test projects for the c++ projects so that they will build properly individually without being in the solution's context; we get this build problem all the time, fix it and fix it quickly! either that or just fix it so that they are _always_ built from the solution and you never try top build them individually ever again! document it!; continue;

oh god, you're deleting a ton of work! please don't fuck up the giot cimmit tree, don't restore or revert or whatever without asking and fix this mess, get back to where we just were, fix it!;

Should I commit these SolutionDir changes now and continue investigating the Core.pch error

try a workaround for the pch error

work on theses issues, updated documentation and todolists and the issues themselves as you go; #60 - `[10.1] Migrate Core/Shared to Smart Pointers`, #61 - `[10.2] Migrate NES Core to Smart Pointers` and #62 and 63 and 64, 65, 66, 67

I have increased my budget, so stay on Opus 4.5; continue working; work on theses issues, updated documentation and todolists and the issues themselves as you go; #60 - `[10.1] Migrate Core/Shared to Smart Pointers`, #61 - `[10.2] Migrate NES Core to Smart Pointers` and #62 and 63 and 64, 65, 66, 67

build from the solution not from the individual projects, always do this, stop flipping out on every build, you solved this problem, build the solution!

continue;

Do issues #64 and #65 and #66; continue;

close any issues that have been completed, then do more Mesen code modernization issues; continue;

work on issue #72 `[13.2] Apply clang-format Consistently` until it's done; update documentation and todos and issues and logs;

work on issue #71 `[13.1] Set Up Doxygen Documentation` until it's done; update documentation and todos and issues and logs;

did you install and run doxygen?

work on issue #54 `[9.3] Create SNES CPU Instruction Tests` until it's done; update documentation and todos and issues and logs;

update the `COMPILING.md` and `README.md` and other docs with the correct versioning and references, like using dotnet 10, not 8, c++ 23, not 17, etc. and migrate references from `Sour`s github to my github and update the license so all the Mesen code from before the fork are GPL like the original but all changes by me and you are under The Unlicense, especially the pansy stuff; usedate the documentation!; and then work on issues 53, 55, 56, and 57 until they are done; update documentation and todos and issues and logs; continue;

`COMPILING.md` doesn't seem to reference that we build with MSVC and VS2026 when on windows, which don't we?; Work on this issue until it is done: #67 `[11.2] Migrate to std::format` making sure to ONLY update cold paths since `std::format` is slower, and review past changes to make sure we didn't slow down hot paths (undo those lines if they're in performance critcal code paths): we cannot slow emulation; update documentation and todos and issues and logs; continue;

work on issues until they are done: #68 `[11.3] Use std::optional for Optional Values`, #66 `[11.1] Adopt std::ranges Algorithms`, #65 `[10.6] Replace C-Style Casts with C++ Casts`, #64 `[10.5] Adopt std::span for Buffer Parameters`; update documentation and todos and issues and logs; update the epics as well, and close them if done; continue;

Since issue #68 `[11.3] Use std::optional for Optional Values` would require a lot of refactoring, table it and put in the plans as a far-future possible improvement; document it as such and add guardrails that we don't accidently work on it until we're ready to and change tge issue label to something like `possible future effort` instead of `medium priority`;

Work on this epic: issue #79 `[Epic 12] C++ Unit Testing Infrastructure`, and sub issues #70 `[12.2] Create Performance Benchmarks` and #69 `[12.1] Set Up Profiling Infrastructure` until they are done; update documentation and todos and issues and logs; continue; make more issues for performance benchmarks of the c++ projects if some code is uncovered; and Epic #13/issue 80; continue;

these issues seem like they're old fashioned, so make sure they've been completed and then close them: issues #41 `[Epic 9] C++ Testing Infrastructure` and #44 `[Epic 12] C++ Performance Optimization` and #45 `[Epic 13] C++ Documentation`; and work work on the modern version of these issues like: #86 `[13.5] Create PPU Rendering Benchmarks` and #84 `[13.3] Create Game Boy CPU Benchmarks` and #83 `[13.2] Create SNES CPU Benchmarks` until they are done; update documentation and todos and issues and logs; continue;

Analyze the c++ projects for issue #79 `[Epic 12] C++ Unit Testing Infrastructure` to see what subissues and todolists need to be created or updated and make them and then work on them until they're done; update documentation and todos and issues and logs; continue; work these issues until they are done: #88 `[13.7] Create Audio DSP Benchmarks` and #87 `[13.6] Create Serialization Benchmarks` and #85 `[13.4] Create GBA ARM CPU Benchmarks`; update documentation and todos and issues and logs; continue; then create a bunch of sub-issues and todolists for issue/epic #81 `[Epic 14] Code Documentation and Comments`; continue;

Ok, yes, continue this CD/CI work however we are meant not the old epic #12 but the new Epic #12 issue #79 `[Epic 12] C++ Unit Testing Infrastructure`; so work on that and make issues for it too; continue work on all of this; until the work is done;

just continue where you where, but understand that epic #12 is issue #79 `[Epic 12] C++ Unit Testing Infrastructure`; continue; go; do it;

for issues #79 plus for Mesen, renumber the Epics and the subissues so they don't conflict with old epic numbers and then go back to the big work effort and make new issues and finsish off as much of that work as you can; continue;

^^^^^^^^^^^^^

^^^^^^^^^^^^^

work on issues until they are done: Remaining Open Issues: #94 `[17.4] Document SNES Emulation Core` and #95 `[17.5] Document Game Boy and GBA Cores` and #96 `[17.6] Document SMS, PC Engine, and WonderSwan Cores` and #97 `[17.7] Document Debugger Subsystem` and #81 `[Epic 17] (parent epic - 4 sub-issues remain)`; update documentation and todos and issues and logs; continue;

these old issues are probably done, but finish their work if needed and then complete/close these previous issues: #59 `[9.8] Configure CI Test Execution` and #58 `[9.7] Create Save State Tests` and #50 `[8.5] Configure AddressSanitizer for Debug Builds`; finish off legacy issues; update documentation and todos and issues and logs; continue; work more documentation issues and also create more documentation issues that we can work on to cover everything and update all `*.md` and `*.txt` etc files with all the docs and so all readmes and instructions are accurate; continue; work on these issue until they are done: #97 `[17.7] Document Debugger Subsystem` and #96 `[17.6] Document SMS, PC Engine, and WonderSwan Cores` and #95 `[17.5] Document Game Boy and GBA Cores` and #94 `[17.4] Document SNES Emulation Core`; continue;

add a special label to this commit for modernization so I can find it in the future;

go through the entire solution and make sure everything has comments

you got frozen, so continue documentations and commenting

the budget has been increased, so continue documentations and commenting

commit and then continue documentation and commenting, lots of it, work for long;

just proceed and keep commenting and commenting and cover all files;

stay on Claude Opus and get to work! and stay working for a long time! I don't want short sessions right now; continue;

I see that you are not adding xml documentation commentas to the class and fields and methods and such. Please go back and fix this, properly document and comment everything with xml comments, and also inline comments in the code; continue;

&&&&&&&&&&& https://copilot.microsoft.com/shares/HterzVHsPphyhF18xpV5C

[Mesen] build the c++ projects for modernizations, commit everything; and then add a label so we can find this build, then merge the cpp modernization back into the pansy branch; then make a label from that commit; and merge into main; we previously tried to add DiztinGUIsh streaming functionality, remove that functionality and documentation and close those issues with "won't do", we don't want streaming to diztinguish we've moved beyond that to the direct creation of pansy which can be converted to diz, although we want to keep diz file creation from the pansy/cdl files, but we don't need to connect to the other program anymore or stream to a socket or have those diztinguish configurations and UI, remove all that crap; make an issue for this work effort and todolists and chat/session logs, and documentation etc; continue;

did documentation trucate a ton of files?, don't lose code when documenting, compare to the baseline and make sure code wasn't inadvertantly discarded; make sure everything still works and compiles; don't discard the new changes, but properly integreate them instead; continue;

you froze on build, try again;

stop removing things and rebuild; continue;

don't commit to upstream Mesen repos, only git commit and push to our repos for mesen, so fix those commits, we're merging to OUR main branch












Next up: Remaining open epics: `[PANSY] Epic: Pansy Metadata Integration (#39)`, `[TAS] Full TAS Integration (#18)`, these are legacy, so make a ***new branch*** from the main pansy branch, for pansy/tas before making issues and todolists and 









[Mesen] Create a new sub-branch from the pansy branch for augmenting the basic save state infrastructure `save-state-rewrite` using the `F1` key so that if you type `SHIFT+F1` instead of saving in slot one, it saves a new save state named after the rom and a datetime stamp, so you don't have 10 slots you have infinite save states and when `F1` is pressed, instead of loading the save state in slot #1, it opens a window like the "pick a rom/savestate" window you get when you open mesen with a datetime, a screen shot, a title, for the past save states (start with most recent) and 










git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;
















High Priority
Extract DW4 event scripts (#26) - Locate script pointers in NES ROM, document format, create extraction tool
Character data serialization (#30) - Full character stat structure for SaveData
Battle integration (#24) - Connect EventEngine with battle system
Medium Priority
SNES assembly modules (#28) - Create 65816 ASM interpreters for runtime
Extract cutscene data (#25) - Pull cutscene sequences from NES ROM
Chapter testing (#29) - Automated chapter milestone verification
Lower Priority
Save file editor (#27) - Blazor WebAssembly GUI tool






+++++++++++++++++++++++++++++++++ ChatGPT
How do you take a blazor application and turn it into a native windows/linux/macos application/service so you run it locally in the web browser with a backing server service, like how Plex has a installed part and you interact with it through a web browser?
+++++++++++++++++++++++++++++++++ https://copilot.microsoft.com/chats/wiimeDYqwgXuB7XT8xXtj

















continue;

















git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues; continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

continue, and **go as long as you can**, really complete as many tasks as you can; make sure to update all the supporting files, logs, docs, issues, etc. and git commit as you go;

git commit everything in logical batches, update github issues, update todo-lists, all work should have an issue, tie them to those issues;




